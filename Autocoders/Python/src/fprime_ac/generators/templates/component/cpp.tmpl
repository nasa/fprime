// ======================================================================
// \title  ${name}ComponentAc.cpp
// \author Auto-generated
// \brief  cpp file for ${name} component base class
//
// NOTE: this file was automatically generated
//
// ======================================================================

\#include <cstdio>
\#include <FpConfig.hpp>
\#include <${comp_include_path}/${include_name}ComponentAc.hpp>
\#include <Fw/Types/Assert.hpp>
\#if FW_ENABLE_TEXT_LOGGING
\#include <Fw/Types/String.hpp>
\#endif

#set $class_name = $name + "ComponentBase"

#if $namespace_list != None
 #for $namespace in $namespace_list
namespace ${namespace} {
 #end for
#end if

#if $kind != "passive":
  // ----------------------------------------------------------------------
  // Anonymous namespace to prevent name collisions
  // ----------------------------------------------------------------------

  namespace {

    typedef enum {
      ${name.upper()}_COMPONENT_EXIT = Fw::ActiveComponentBase::ACTIVE_COMPONENT_EXIT,
  #for $msg_type in $msg_types[0:-1]
      ${msg_type},
  #end for
  #if len($msg_types) > 0:
      $msg_types[-1].upper()
  #end if
    } MsgTypeEnum;

    // Get the max size by doing a union of the input port serialization sizes.

    typedef union {
  #set $num = 1
  #set $used = False
  #for $type in $port_input_types:
    #set $namespace = $port_namespaces[$type]
      BYTE port${num}[${namespace}::Input${type}Port::SERIALIZED_SIZE];
    #set $num = $num + 1
    #set $used = True
  #end for
  #if $has_commands
    #set $used = True
      BYTE cmdPort[Fw::InputCmdPort::SERIALIZED_SIZE];
  #end if
  #if $has_internal_interfaces
    #set $used = True
    #for $iname, $ipriority, $full in $internal_interfaces:
      // Size of $iname argument list
      BYTE ${iname}IntIfSize[
      #for $argname, $type, $comment, $typeinfo in $internal_interface_args[$iname]:
        #if $typeinfo == None
        sizeof(${type}) +
        #else if $typeinfo == "enum"
        sizeof(FwEnumStoreType) +
        #else
        ${type}::SERIALIZED_SIZE +
        #end if
      #end for
        0
      ];
    #end for
  #end if
  #if $used == False
      // Minimum size for no async input types
      BYTE NOSIZE;
  #end if
    } BuffUnion;

    // Define a message buffer class large enough to handle all the
    // asynchronous inputs to the component

    class ComponentIpcSerializableBuffer :
      public Fw::SerializeBufferBase
    {

      public:

        enum {
          // Max. message size = size of data + message id + port
          SERIALIZATION_SIZE =
            sizeof(BuffUnion) +
            sizeof(NATIVE_INT_TYPE) +
            sizeof(NATIVE_INT_TYPE)
        };

        NATIVE_UINT_TYPE getBuffCapacity() const {
          return sizeof(m_buff);
        }

        U8* getBuffAddr() {
          return m_buff;
        }

        const U8* getBuffAddr() const {
          return m_buff;
        }

      private:
        // Should be the max of all the input ports serialized sizes...
        U8 m_buff[SERIALIZATION_SIZE];

    };

  }

#end if
#if $has_input_ports:
  // ----------------------------------------------------------------------
  // Getters for numbers of input ports
  // ----------------------------------------------------------------------

  #for $instance, $type, $sync, $priority, $full, $role, $max_num in $input_ports:
    #set $namespace = $port_namespaces[$type]
    #if $type == "Serial":
  Fw::InputSerializePort *${class_name} ::
    #else:
  $namespace::Input${type}Port *${class_name} ::
    #end if
    get_${instance}_InputPort(NATIVE_INT_TYPE portNum)
  {
    FW_ASSERT(portNum < this->getNum_${instance}_InputPorts(),static_cast<FwAssertArgType>(portNum));
    return &this->m_${instance}_InputPort[portNum];
  }

  #end for
#end if
#if $has_output_ports
  // ----------------------------------------------------------------------
  // Typed connectors for output ports
  // ----------------------------------------------------------------------

  #for $instance, $type, $sync, $priority, $role, $max_num in $output_ports:
    #set $namespace = $port_namespaces[$type]
    #if $role == "LogTextEvent":
\#if FW_ENABLE_TEXT_LOGGING == 1
    #end if
  void ${class_name} ::
    set_${instance}_OutputPort(
        NATIVE_INT_TYPE portNum,
    #if $type == "Serial":
        Fw::InputSerializePort* port
    #else
        $namespace::Input${type}Port* port
    #end if
    )
  {
    FW_ASSERT(portNum < this->getNum_${instance}_OutputPorts(),static_cast<FwAssertArgType>(portNum));
    #if $type == "Serial":
    this->m_${instance}_OutputPort[portNum].registerSerialPort(port);
    #else:
    this->m_${instance}_OutputPort[portNum].addCallPort(port);
    #end if
  }
    #if $role == "LogTextEvent":
\#endif
    #end if

  #end for
  // ----------------------------------------------------------------------
  // Serialization connectors for output ports
  // ----------------------------------------------------------------------

\#if FW_PORT_SERIALIZATION

  #for $instance, $type, $sync, $priority, $role, $max_num in $output_ports:
    #if $role == "LogTextEvent":
\#if FW_ENABLE_TEXT_LOGGING == 1
    #end if
  void ${class_name} ::
    set_${instance}_OutputPort(
        NATIVE_INT_TYPE portNum,
    #if $type == "Serial":
        Fw::InputPortBase *port
    #else:
        Fw::InputSerializePort *port
    #end if
    )
  {
    FW_ASSERT(portNum < this->getNum_${instance}_OutputPorts(),static_cast<FwAssertArgType>(portNum));
    return this->m_${instance}_OutputPort[portNum].registerSerialPort(port);
  }
    #if $role == "LogTextEvent":
\#endif
    #end if

  #end for
\#endif

#end if
#if $has_commands or $has_parameters
  // ----------------------------------------------------------------------
  // Command registration
  // ----------------------------------------------------------------------

  void ${class_name} ::
    regCommands()
  {
    FW_ASSERT(this->m_${CmdReg_Name}_OutputPort[0].isConnected());
  #for $mnemonic, $opcodes, $sync, $priority, $full, $comment in $commands:
    #if len($opcodes) == 1:
    this->m_${CmdReg_Name}_OutputPort[0].invoke(
        this->getIdBase() + OPCODE_${mnemonic.upper}
    );
    #else
      #set $inst = 0
    switch (this->getInstance()) {
      #for $opcode in $opcodes:
      case $inst:
          this->m_${CmdReg_Name}_OutputPort[0].invoke(
              this->getIdBase() + OPCODE_${mnemonic.upper}_${inst}
          );
          break;
      #set $inst = $inst + 1
      #end for
      default:
          FW_ASSERT(0,this->getInstance());
          break;
    }
    #end if
  #end for
  #for $ids, $prmname, $type, $osets, $osaves, $size, $default, $comment, $typeinfo in $parameters:
    #if len($osets) == 1
    this->m_${CmdReg_Name}_OutputPort[0].invoke(
        this->getIdBase() + OPCODE_${prmname.upper}_SET
    );
    #else
      #set $inst = 0
    switch (this->getInstance()) {
      #for $opcode in $osets
      case $inst:
          this->m_${CmdReg_Name}_OutputPort[0].invoke(
              this->getIdBase() + OPCODE_${prmname.upper}_${inst}_SET
          );
          break;
      #set $inst = $inst + 1
      #end for
      default:
          FW_ASSERT(0,this->getInstance());
          break;
    }
    #end if
    #if len($osaves) == 1
    this->m_${CmdReg_Name}_OutputPort[0].invoke(
        this->getIdBase() + OPCODE_${prmname.upper}_SAVE
    );
    #else
      #set $inst = 0
    switch (this->getInstance()) {
      #for $opcode in $osaves
      case $inst:
          this->m_${CmdReg_Name}_OutputPort[0].invoke(
              this->getIdBase() + OPCODE_${prmname.upper}_${inst}_SAVE
          );
          break;
      #set $inst = $inst + 1
      #end for
      default:
          FW_ASSERT(0,this->getInstance());
          break;
    }
    #end if
  #end for
  }

#end if
#if $has_parameters
  // ----------------------------------------------------------------------
  // Parameter loading
  // ----------------------------------------------------------------------

  void ${class_name}::loadParameters() {

    Fw::ParamBuffer buff;
    Fw::SerializeStatus stat = Fw::FW_SERIALIZE_OK;
    FW_ASSERT(this->m_${ParamGet_Name}_OutputPort[0].isConnected());

    FwPrmIdType _id;
  #for $ids, $prmname, $type, $osets, $osaves, $size, $default, $comment, $typeinfo in $parameters:
    // choose parameter ID to get
    #if len($ids) == 1
    _id = this->getIdBase() + PARAMID_${prmname.upper};
    #else
       switch (this->getInstance()) {
       #set $inst = 0
       #for $id in $ids
          case ${inst}:
             _id = this->getIdBase() + PARAMID_${prmname.upper}_${inst};
             break;
          #set $inst = $inst + 1
       #end for
          default:
             // Silence compiler warning
             _id = static_cast<FwPrmIdType>(0);
             FW_ASSERT(0,this->getInstance());
             break;
       }
    #end if
    // Get parameter ${prmname}
    this->m_param_${prmname}_valid =
      this->m_${ParamGet_Name}_OutputPort[0].invoke(
          _id,
          buff
      );

    // Deserialize value
    this->m_paramLock.lock();

    if (this->m_param_${prmname}_valid == Fw::ParamValid::VALID) {
    #if $typeinfo == "enum":
      FwEnumStoreType ${prmname}Val = 0;
      stat = buff.deserialize(${prmname}Val);
      this->m_${prmname} = static_cast<$type>(${prmname}Val);
    #else
      stat = buff.deserialize(this->m_${prmname});
    #end if
      // If there was a deserialization issue, mark it invalid.
      if (stat != Fw::FW_SERIALIZE_OK) {
    #if $default == None:
        this->m_param_${prmname}_valid = Fw::ParamValid::INVALID;
    #else if $type == "string":
        this->m_param_${prmname}_valid = Fw::ParamValid::DEFAULT;
        // set default value
        this->m_${prmname} = "${default}";
    #else
        this->m_param_${prmname}_valid = Fw::ParamValid::DEFAULT;
        // set default value
        this->m_${prmname} = ${default};
    #end if
      }
    }
    else {
    #if $default == None:
      // No default
    #else if $type == "string":
      // set default value
      this->m_param_${prmname}_valid = Fw::ParamValid::DEFAULT;
      this->m_${prmname} = "${default}";
    #else
      // set default value
      this->m_param_${prmname}_valid = Fw::ParamValid::DEFAULT;
      this->m_${prmname} = ${default};
    #end if
    }

    this->m_paramLock.unLock();

  #end for
    // Call notifier
    this->parametersLoaded();
  }

#end if
  // ----------------------------------------------------------------------
  // Component construction, initialization, and destruction
  // ----------------------------------------------------------------------

#if $kind == "passive":
    ${class_name} :: ${class_name}(const char* compName) :
        Fw::PassiveComponentBase(compName) {
#else if $kind == "queued":
    ${class_name} :: ${class_name}(const char* compName) :
        Fw::QueuedComponentBase(compName) {
#else:
    ${class_name} :: ${class_name}(const char* compName) :
        Fw::ActiveComponentBase(compName) {
#end if

  #for $ids, $tlmname, $type, $size, $update, $comment, $typeinfo in $channels:
    #if $update != None and $update != "always"
    // Initialize telemetry channel $tlmname
    this->m_first_update_${tlmname} = true;
      #if $typeinfo == None
    this->m_last_${tlmname} = 0;
      #else if $typeinfo == "enum"
    this->m_last_${tlmname} = static_cast<$type>(0);
      #end if
    #end if
  #end for

  #for $ids, $eventname, $severity, $format_string, $throttle, $comment in $events:
    #if $throttle != None
    this->m_${eventname}Throttle = 0;
    #end if
  #end for

  #for $ids, $prmname, $type, $osets, $osaves, $size, $default, $comment, $typeinfo in $parameters:
    this->m_param_${prmname}_valid = Fw::ParamValid::UNINIT;
  #end for
  }

  void ${class_name} ::
#if $kind == "passive":
    init(NATIVE_INT_TYPE instance)
#else if $needs_msg_size:
    init(
        NATIVE_INT_TYPE queueDepth,
        NATIVE_INT_TYPE msgSize,
        NATIVE_INT_TYPE instance
    )
#else:
    init(
        NATIVE_INT_TYPE queueDepth,
        NATIVE_INT_TYPE instance
    )
#end if
  {

    // Initialize base class
#if $kind == "passive":
    Fw::PassiveComponentBase::init(instance);
#else if $kind == "queued":
    Fw::QueuedComponentBase::init(instance);
#else if $kind == "active":
    Fw::ActiveComponentBase::init(instance);
#end if

#for $instance, $type, $sync, $priority, $full, $role, $max_num in $input_ports:
    // Connect input port $instance
    for (
        PlatformIntType port = 0;
        port < static_cast<PlatformIntType>(this->getNum_${instance}_InputPorts());
        port++
    ) {

      this->m_${instance}_InputPort[port].init();
      this->m_${instance}_InputPort[port].addCallComp(
          this,
          m_p_${instance}_in
      );
      this->m_${instance}_InputPort[port].setPortNum(port);

\#if FW_OBJECT_NAMES == 1
      char portName[120];
      (void) snprintf(
          portName,
          sizeof(portName),
          "%s_${instance}_InputPort[%" PRI_PlatformIntType "]",
          this->m_objName,
          port
      );
      this->m_${instance}_InputPort[port].setObjName(portName);
\#endif

    }

#end for
#for $instance, $type, $sync, $priority, $role, $max_num in $output_ports:
    // Initialize output port $instance
  #if $role == 'LogTextEvent':
\#if FW_ENABLE_TEXT_LOGGING == 1
  #end if
    for (
        PlatformIntType port = 0;
        port < static_cast<PlatformIntType>(this->getNum_${instance}_OutputPorts());
        port++
    ) {
      this->m_${instance}_OutputPort[port].init();

\#if FW_OBJECT_NAMES == 1
      char portName[120];
      (void) snprintf(
          portName,
          sizeof(portName),
          "%s_${instance}_OutputPort[%" PRI_PlatformIntType "]",
          this->m_objName,
          port
      );
      this->m_${instance}_OutputPort[port].setObjName(portName);
\#endif

    }
  #if $role == 'LogTextEvent':
\#endif
  #end if

#end for
#if $kind != "passive":
  #if $needs_msg_size
    // Passed-in size added to port number and message type enumeration sizes.
    // NATIVE_INT_TYPE cast because of compiler warning.
    this->m_msgSize = FW_MAX(msgSize +
        static_cast<NATIVE_INT_TYPE>(sizeof(NATIVE_INT_TYPE)) +
        static_cast<NATIVE_INT_TYPE>(sizeof(I32)),
        static_cast<NATIVE_INT_TYPE>(ComponentIpcSerializableBuffer::SERIALIZATION_SIZE));

    Os::Queue::QueueStatus qStat =
    this->createQueue(queueDepth,this->m_msgSize);
  #else
    Os::Queue::QueueStatus qStat =
    this->createQueue(
        queueDepth,
        ComponentIpcSerializableBuffer::SERIALIZATION_SIZE
    );
  #end if
    FW_ASSERT(
        Os::Queue::QUEUE_OK == qStat,
        static_cast<FwAssertArgType>(qStat)
    );
#end if

  }

  ${class_name}::
    ~${class_name}() {

  }

  // ----------------------------------------------------------------------
  // Invocation functions for output ports
  // ----------------------------------------------------------------------

#for $instance, $type, $sync, $priority, $role, $max_num in $invocation_functions:
  #set $params = $port_param_strs[$instance]
  #set $args = $port_arg_strs[$instance]
  #set $return_type = $port_return_type_strs[$instance]
  #set $void_params = $params == "void"
  #set $void_return = $return_type[:4] == "void"
  #if $type == "Serial":
    #set $return_type = "Fw::SerializeStatus "
  #end if
  ${return_type}${class_name} ::
  #if $type == "Serial":
    ${instance}_out(
        NATIVE_INT_TYPE portNum,
        Fw::SerializeBufferBase &Buffer
    )
  {
    FW_ASSERT(portNum < this->getNum_${instance}_OutputPorts(),static_cast<FwAssertArgType>(portNum));
    return this->m_${instance}_OutputPort[portNum].invokeSerial(Buffer);
  }
  #else
    #if $void_params:
    ${instance}_out(NATIVE_INT_TYPE portNum)
  {
    #else:
    ${instance}_out(
        NATIVE_INT_TYPE portNum,
        $params
    )
  {
    #end if
    FW_ASSERT(portNum < this->getNum_${instance}_OutputPorts(),static_cast<FwAssertArgType>(portNum));
    #if $void_return:
    this->m_${instance}_OutputPort[portNum].invoke($args);
    #else:
    return this->m_${instance}_OutputPort[portNum].invoke($args);
    #end if
  }
  #end if

#end for
#if $has_ports:
  // ----------------------------------------------------------------------
  // Getters for numbers of ports
  // ----------------------------------------------------------------------

  #for $instance, $type, $direction, $sync, $priority, $full, $role, $max_num in $ports_all:
    #if $role == "LogTextEvent":
\#if FW_ENABLE_TEXT_LOGGING == 1
    #end if
  NATIVE_INT_TYPE ${class_name} ::
    getNum_${instance}_${direction}Ports()
  {
    return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_${instance}_${direction}Port));
  }
    #if $role == "LogTextEvent":
\#endif
    #end if

  #end for
#end if
#if $has_output_ports:
  // ----------------------------------------------------------------------
  // Port connection status queries
  // ----------------------------------------------------------------------

  #for $instance, $type, $sync, $priority, $role, $max_num in $output_ports:
    #if $role == "LogTextEvent":
\#if FW_ENABLE_TEXT_LOGGING == 1
    #end if
  bool ${class_name} ::
    isConnected_${instance}_OutputPort(NATIVE_INT_TYPE portNum)
  {
     FW_ASSERT(
        portNum < this->getNum_${instance}_OutputPorts(),
        static_cast<FwAssertArgType>(portNum)
     );
     return this->m_${instance}_OutputPort[portNum].isConnected();
  }
    #if $role == "LogTextEvent":
\#endif
    #end if

  #end for
#end if
#if $has_commands or $has_parameters
  // ----------------------------------------------------------------------
  // Calls for messages received on command input ports
  // ----------------------------------------------------------------------

  void ${class_name} ::
    m_p_${Cmd_Name}_in(
        Fw::PassiveComponentBase* callComp,
        NATIVE_INT_TYPE portNum,
        FwOpcodeType opCode,
        U32 cmdSeq,
        Fw::CmdArgBuffer &args
    )
  {

    // Select base class function based on opcode
    FW_ASSERT(callComp);
    ${class_name}* compPtr = static_cast<${class_name}*>(callComp);

    const U32 idBase = callComp->getIdBase();
    FW_ASSERT(opCode >= idBase, opCode, idBase);
    switch (opCode - idBase) {

  #for $mnemonic, $opcodes, $sync, $priority, $full, $comment in $commands:
    #if len($opcodes) == 1
      case OPCODE_${mnemonic.upper}: /*!< $comment */
    #else
      #set $inst = 0
      #for $opcode in $opcodes:
      case OPCODE_${mnemonic.upper}_${inst}: /*!< $comment */
         #set $inst = $inst + 1
      #end for
    #end if
        compPtr->${mnemonic}_cmdHandlerBase(
            opCode,
            cmdSeq,
            args
        );
        break;

  #end for
  #for $ids, $prmname, $type, $osets, $osaves, $size, $default, $comment, $typeinfo in $parameters:
    #if len($ids) == 1
      case OPCODE_${prmname.upper}_SET:
    #else
      #set $inst = 0
      #for $id in $ids
      case OPCODE_${prmname.upper}_${inst}_SET:
        #set $inst = $inst + 1
      #end for
    #end if
      {
        Fw::CmdResponse _cstat = compPtr->paramSet_${prmname}(args);
        compPtr->cmdResponse_out(
            opCode,
            cmdSeq,
            _cstat
        );
        break;
      }
    #if len($ids) == 1
      case OPCODE_${prmname.upper}_SAVE:
    #else
      #set $inst = 0
      #for $id in $ids
      case OPCODE_${prmname.upper}_${inst}_SAVE:
        #set $inst = $inst + 1
      #end for
    #end if
      {
        Fw::CmdResponse _cstat = compPtr->paramSave_${prmname}();
        compPtr->cmdResponse_out(
            opCode,
            cmdSeq,
            _cstat
        );
        break;
      }
  #end for
      default: {
        compPtr->cmdResponse_out(
            opCode,cmdSeq,
            Fw::CmdResponse::INVALID_OPCODE
        );
        break;
      }

    }

  }

  void ${class_name} ::
    cmdResponse_out(
        FwOpcodeType opCode,
        U32 cmdSeq,
        Fw::CmdResponse response
    )
  {
    FW_ASSERT(this->m_${CmdStatus_Name}_OutputPort[0].isConnected());
    this->m_${CmdStatus_Name}_OutputPort[0].invoke(opCode,cmdSeq,response);
  }

#end if
#if $has_commands
  // ----------------------------------------------------------------------
  // Base class command functions
  // ----------------------------------------------------------------------

  #for $mnemonic, $opcodes, $sync, $priority, $full, $comment in $commands:
  void ${class_name} ::
    ${mnemonic}_cmdHandlerBase(
        FwOpcodeType opCode,
        U32 cmdSeq,
        Fw::CmdArgBuffer &args
    )
  {

    #if $sync == 'guarded' or $sync == 'sync':
      #set $args = $command_args[$mnemonic]
      #if len($args):
    // Deserialize the arguments
    Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

    // Reset the buffer
    args.resetDeser();

        #for $arg_name, $arg_type, $comment, $is_enum in $args:
    $arg_type $arg_name;
          #if $is_enum == "enum":
    FwEnumStoreType ${arg_name}Int = 0;
    _status = args.deserialize(${arg_name}Int);
    $arg_name = static_cast<${arg_type}>(${arg_name}Int);
          #else
    _status = args.deserialize($arg_name);
          #end if
    if (_status != Fw::FW_SERIALIZE_OK) {
      if (this->m_${CmdStatus_Name}_OutputPort[0].isConnected()) {
        this->m_${CmdStatus_Name}_OutputPort[0].invoke(
            opCode,
            cmdSeq,Fw::CmdResponse::FORMAT_ERROR
        );
      }
      return;
    }

        #end for
      #end if
\#if FW_CMD_CHECK_RESIDUAL
    // Make sure there was no data left over.
    // That means the argument buffer size was incorrect.
    if (args.getBuffLeft() != 0) {
      if (this->m_${CmdStatus_Name}_OutputPort[0].isConnected()) {
        this->m_${CmdStatus_Name}_OutputPort[0].invoke(
            opCode,
            cmdSeq,Fw::CmdResponse::FORMAT_ERROR
        );
      }
      return;
    }
\#endif
      #if $sync == 'guarded'
    this->lock();
      #end if
      #if len($args) == 0:
    this->${mnemonic}_cmdHandler(opCode,cmdSeq);
      #else
    this->${mnemonic}_cmdHandler(
        opCode,
        cmdSeq,
        $command_args_str($args)
    );
      #end if
      #if $sync == 'guarded'
    this->unLock();
      #end if

    #end if
    #if $sync == 'async'
    // Call pre-message hook
    this->${mnemonic}_preMsgHook(opCode,cmdSeq);

    // Defer deserializing arguments to the message dispatcher
    // to avoid deserializing and reserializing just for IPC
    ComponentIpcSerializableBuffer msg;
    Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

    // Serialize for IPC
    #if len($opcodes) == 1
    _status = msg.serialize(static_cast<NATIVE_INT_TYPE>(CMD_${mnemonic.upper()}));
    #else
    switch (this->getInstance()) {
       #set $inst = 0
       #for $opcode in $opcodes
        case $inst:
            _status = msg.serialize(static_cast<NATIVE_INT_TYPE>(CMD_${mnemonic.upper()}_${inst}));
            break;
         #set $inst = $inst + 1
       #end for
        default:
           // Silence compiler warning
           _status = static_cast<Fw::SerializeStatus>(0);
           FW_ASSERT(0,this->getInstance());
           break;
    };
    #end if
    FW_ASSERT (
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
        );

    // Fake port number to make message dequeue work
    NATIVE_INT_TYPE port = 0;
    _status = msg.serialize(port);
    FW_ASSERT (
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
    );

    _status = msg.serialize(opCode);
    FW_ASSERT (
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
    );

    _status = msg.serialize(cmdSeq);
    FW_ASSERT (
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
    );

    _status = msg.serialize(args);
    FW_ASSERT (
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
    );

    // send message
    Os::Queue::QueueBlocking _block =
      #if $full == 'block'
      Os::Queue::QUEUE_BLOCKING;
      #else
      Os::Queue::QUEUE_NONBLOCKING;
      #end if
    Os::Queue::QueueStatus qStatus =
      this->m_queue.send(msg, ${priority},_block);
      #if $full == 'drop'
    if (qStatus == Os::Queue::QUEUE_FULL) {
        this->incNumMsgDropped();
        return;
    }
      #end if
    FW_ASSERT(
        qStatus == Os::Queue::QUEUE_OK,
        static_cast<FwAssertArgType>(qStatus)
    );

    #end if
  }

    #if $sync == "async":
  void ${class_name}::
    ${mnemonic}_preMsgHook(
        FwOpcodeType opCode,
        U32 cmdSeq
    )
  {
    // Defaults to no-op; can be overridden
  }

    #end if
  #end for
#end if
#if $has_telemetry:
  // ----------------------------------------------------------------------
  // Telemetry write functions
  // ----------------------------------------------------------------------

  #for $ids, $tlmname, $type, $size, $update, $comment, $typeinfo in $channels:
    #set $tlm_type = $type
    #if $type == "string":
      #set $tlm_type = "const Fw::TlmString&"
    #else if $typeinfo == "user"
      #set $tlm_type = "const " + $type + "&"
    #else
      #set $tlm_type = $type
    #end if
  void ${class_name} ::
    tlmWrite_${tlmname}(${tlm_type} arg, Fw::Time _tlmTime)
  {
    #if $update == "on_change"
    // Check to see if it is the first time
    if (not this->m_first_update_$tlmname) {
      // Check to see if value has changed. If not, don't write it.
      if (arg == this->m_last_$tlmname) {
        return;
      } else {
        this->m_last_$tlmname = arg;
      }
    }
    else {
      this->m_first_update_$tlmname = false;
      this->m_last_$tlmname = arg;
    }

    #end if
    if (this->m_${Tlm_Name}_OutputPort[0].isConnected()) {
      if (this->m_${Time_Name}_OutputPort[0].isConnected() && _tlmTime ==  Fw::ZERO_TIME) {
         this->m_${Time_Name}_OutputPort[0].invoke( _tlmTime);
      }
      Fw::TlmBuffer _tlmBuff;
    #if $type == "string":
      Fw::SerializeStatus _stat = arg.serialize(_tlmBuff, $size);
    #else if $typeinfo == "enum":
      Fw::SerializeStatus _stat = _tlmBuff.serialize(static_cast<FwEnumStoreType>(arg));
    #else
      Fw::SerializeStatus _stat = _tlmBuff.serialize(arg);
    #end if
      FW_ASSERT(
          _stat == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_stat)
      );

      FwChanIdType _id;

    #if len($ids) == 1
      _id = this->getIdBase() + CHANNELID_${tlmname.upper};
    #else
      #set $inst = 0
      switch (this->getInstance()) {
      #for $id in $ids
          case $inst:
            _id = this->getIdBase() + CHANNELID_${tlmname.upper}_${inst};
            break;
         #set $inst = $inst + 1
      #end for
          default:
            // Silence compiler warning
            _id = static_cast<FwChanIdType>(0);
            FW_ASSERT(0,this->getInstance());
            break;
      }
    #end if

      this->m_${Tlm_Name}_OutputPort[0].invoke(
          _id,
          _tlmTime,
          _tlmBuff
      );
    }

  }

  #end for
#end if
#if $has_telemetry or $has_events or $has_time_get
  // ----------------------------------------------------------------------
  // Time
  // ----------------------------------------------------------------------

  Fw::Time ${class_name} ::
    getTime()
  {
    if (this->m_${Time_Name}_OutputPort[0].isConnected()) {
      Fw::Time _time;
      this->m_${Time_Name}_OutputPort[0].invoke(_time);
      return _time;
    } else {
      return Fw::Time(TB_NONE,0,0);
    }
  }

#end if
#if $has_parameters
  // ----------------------------------------------------------------------
  // Parameter update hook
  // ----------------------------------------------------------------------

  void ${class_name} ::
    parameterUpdated(FwPrmIdType id)
  {
    // Do nothing by default
  }

  // ----------------------------------------------------------------------
  // Parameter load hook
  // ----------------------------------------------------------------------

  void ${class_name} ::
    parametersLoaded()
  {
    // Do nothing by default
  }

  // ----------------------------------------------------------------------
  // Protected parameter get functions
  // ----------------------------------------------------------------------

  #for $ids, $prmname, $type, $osets, $osaves, $size, $default, $comment, $typeinfo in $parameters:
    #if $type == "string":
  Fw::ParamString ${class_name} ::
    paramGet_${prmname}(Fw::ParamValid& valid)
  {
    Fw::ParamString _local;
    #else if typeinfo == "enum":
  ${class_name}::${type} ${class_name} ::
    paramGet_${prmname}(Fw::ParamValid& valid)
  {
    ${class_name}::${type} _local;
    #else
  ${type} ${class_name} ::
    paramGet_${prmname}(Fw::ParamValid& valid)
  {
    ${type} _local;
    #end if
    this->m_paramLock.lock();
    valid = this->m_param_${prmname}_valid;
    _local = this->m_${prmname};
    this->m_paramLock.unLock();
    return _local;
  }

  #end for
  // ----------------------------------------------------------------------
  // Private parameter get function
  // ----------------------------------------------------------------------

  Fw::ParamValid ${class_name} ::
    getParam(
      FwPrmIdType id,
      Fw::ParamBuffer& buff
    )
  {
    if (this->m_${ParamGet_Name}_OutputPort[0].isConnected()) {
      return this->m_${ParamGet_Name}_OutputPort[0].invoke(id,buff);
    } else {
      return Fw::ParamValid::INVALID;
    }

  }

  // ----------------------------------------------------------------------
  // Parameter set functions
  // ----------------------------------------------------------------------

  #for $ids, $prmname, $type, $osets, $osaves, $size, $default, $comment, $typeinfo in $parameters:
  Fw::CmdResponse ${class_name} ::
    paramSet_${prmname}(Fw::SerializeBufferBase &val)
  {

    #if $typeinfo == "enum"
    FwEnumStoreType _local_val = 0;
    Fw::SerializeStatus _stat = val.deserialize(_local_val);
    if (_stat != Fw::FW_SERIALIZE_OK) {
      return Fw::CmdResponse::VALIDATION_ERROR;
    }

    this->m_paramLock.lock();
    // Assign the value only if successfully deserialized
    this->m_${prmname} = static_cast<$type>(_local_val);
    #else
      #if $type == "string"
    Fw::ParamString _local_val;
      #else
    $type _local_val;
      #end if
    Fw::SerializeStatus _stat = val.deserialize(_local_val);
    if (_stat != Fw::FW_SERIALIZE_OK) {
      return Fw::CmdResponse::VALIDATION_ERROR;
    }

    // Assign value only if successfully deserialized
    this->m_paramLock.lock();
    this->m_${prmname} = _local_val;
    #end if
    this->m_param_${prmname}_valid = Fw::ParamValid::VALID;
    this->m_paramLock.unLock();

    // Call notifier
    this->parameterUpdated(PARAMID_${prmname.upper});
    return Fw::CmdResponse::OK;

  }

  // ----------------------------------------------------------------------
  // Parameter save functions
  // ----------------------------------------------------------------------

  Fw::CmdResponse ${class_name} ::
    paramSave_${prmname}()
  {

    if (this->m_${ParamSet_Name}_OutputPort[0].isConnected()) {
      Fw::ParamBuffer saveBuff;
      this->m_paramLock.lock();

    #if $typeinfo == "enum":
      Fw::SerializeStatus stat =
        saveBuff.serialize(static_cast<FwEnumStoreType>(m_${prmname}));
    #else
      Fw::SerializeStatus stat =
        saveBuff.serialize(m_${prmname});
    #end if
      this->m_paramLock.unLock();
      if (stat != Fw::FW_SERIALIZE_OK) {
        return Fw::CmdResponse::VALIDATION_ERROR;
      }

      FwPrmIdType id = 0;
    #if len($ids) == 1
      id = this->getIdBase() + PARAMID_${prmname.upper};
    #else
      switch (this->getInstance()) {
      #set $inst = 0
      #for $id in $ids
         case $inst:
            id = this->getIdBase() + PARAMID_${prmname.upper}_${inst};
            break;
         #set $inst = $inst + 1
      #end for
         default:
            FW_ASSERT(0,this->getInstance());
            break;
      }
    #end if
      // Save the parameter
      this->m_${ParamSet_Name}_OutputPort[0].invoke(
          id,
          saveBuff
      );
      return Fw::CmdResponse::OK;

    }

    return Fw::CmdResponse::EXECUTION_ERROR;

  }

  #end for
#end if
#if $has_events:
  // ----------------------------------------------------------------------
  // Event handling functions
  // ----------------------------------------------------------------------

  #for $ids, $eventname, $severity, $format_string, $throttle, $comment in $events:
    #set $params = $event_param_strs[$eventname]
  void ${class_name} ::
    log_${severity}_${eventname}(
        $params
    )
  {

    #if $throttle != None
    // check throttle value
    if (this->m_${eventname}Throttle >= EVENTID_${eventname.upper}_THROTTLE) {
        return;
    } else {
        this->m_${eventname}Throttle++;
    }
    #end if

    // Get the time
    Fw::Time _logTime;
    if (this->m_${Time_Name}_OutputPort[0].isConnected()) {
       this->m_${Time_Name}_OutputPort[0].invoke( _logTime);
    }

    FwEventIdType _id = static_cast<FwEventIdType>(0);

    #if len($ids) == 1
    _id = this->getIdBase() + EVENTID_${eventname.upper};
    #else
    switch (this->getInstance()) {
      #set $inst = 0
      #for $id in $ids
      case $inst:
        _id = this->getIdBase() + EVENTID_${eventname.upper}_${inst};
        break;
        #set $inst = $inst + 1
      #end for
      default:
        FW_ASSERT(0,this->getInstance());
        break;
    };
  #end if

    // Emit the event on the log port
    if (this->m_${LogEvent_Name}_OutputPort[0].isConnected()) {

      Fw::LogBuffer _logBuff;
    #set $args = $event_args[$eventname]
    #if len($args):
      Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

\#if FW_AMPCS_COMPATIBLE
#if $severity == "FATAL"
      // Serialize the number of arguments
      _status = _logBuff.serialize(static_cast<U8>($len($args)+1));
      FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
      );
      // For FATAL, add stack size of 4 and a dummy entry. No support for stacks yet.
      _status = _logBuff.serialize(static_cast<U8>(4));
      FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
      );
      _status = _logBuff.serialize(static_cast<U32>(0));
      FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
      );
#else
      // Serialize the number of arguments
      _status = _logBuff.serialize(static_cast<U8>($len($args)));
      FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
      );
      #end if
\#endif
    #else
\#if FW_AMPCS_COMPATIBLE
      // for AMPCS, need to encode zero arguments
      Fw::SerializeStatus _zero_status = Fw::FW_SERIALIZE_OK;
      _zero_status = _logBuff.serialize(static_cast<U8>(0));
      FW_ASSERT(
          _zero_status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_zero_status)
      );
\#endif
    #end if

    #for $arg_name, $arg_type, $comment, $size, $typeinfo in $args:
      #if $typeinfo == "enum"
\#if FW_AMPCS_COMPATIBLE
      // Serialize the argument size
      _status = _logBuff.serialize(static_cast<U8>(sizeof(FwEnumStoreType)));
      FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
      );
\#endif

      _status = _logBuff.serialize(
          static_cast<FwEnumStoreType>(${arg_name})
      );
      #else if $typeinfo == "string":
      _status = ${arg_name}.serialize(_logBuff, ${size});
      #else
\#if FW_AMPCS_COMPATIBLE
      // Serialize the argument size
      _status = _logBuff.serialize(
          static_cast<U8>(sizeof($size))
      );
      FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
      );
\#endif
      _status = _logBuff.serialize($arg_name);
      #end if
      FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
      );

    #end for

      this->m_${LogEvent_Name}_OutputPort[0].invoke(
          _id,
          _logTime,Fw::LogSeverity::${severity},
          _logBuff
      );

    }

    // Emit the event on the text log port
\#if FW_ENABLE_TEXT_LOGGING
    if (this->m_${LogTextEvent_Name}_OutputPort[0].isConnected()) {

\#if FW_OBJECT_NAMES == 1
      const char* _formatString =
        "(%s) %s: ${format_string}";
\#else
      const char* _formatString =
        "%s: ${format_string}";
\#endif

      char _textBuffer[FW_LOG_TEXT_BUFFER_SIZE];

    #for $arg_name, $arg_type, $comment, $size, $typeinfo in $args:
      #if not ($is_primitive_type($arg_type) or ($typeinfo == "enum") or ($typeinfo == "string")) :
      Fw::String ${arg_name}Str;
      ${arg_name}.toString(${arg_name}Str);
      #end if
    #end for
      (void) snprintf(
          _textBuffer,
          FW_LOG_TEXT_BUFFER_SIZE,
          _formatString,
\#if FW_OBJECT_NAMES == 1
          this->m_objName,
\#endif
          "${eventname} "
    #for $arg_name, $arg_type, $comment, $size, $typeinfo in $args:
      #if $is_primitive_type($arg_type) or ($typeinfo == "enum"):
        , ${arg_name}
      #else if $typeinfo == "string":
        , ${arg_name}.toChar()
      #else
        , ${arg_name}Str.toChar()
      #end if
    #end for
      );

      // Null terminate
      _textBuffer[FW_LOG_TEXT_BUFFER_SIZE-1] = 0;
      Fw::TextLogString _logString = _textBuffer;
      this->m_${LogTextEvent_Name}_OutputPort[0].invoke(
          _id,
          _logTime,Fw::LogSeverity::${severity},
          _logString
      );

    }
\#endif

  }

  #if $throttle != None
    void ${class_name}::log_${severity}_${eventname}_ThrottleClear() {
        // reset throttle counter
        this->m_${eventname}Throttle = 0;
    }
  #end if

  #end for
#end if
#if $has_internal_interfaces:
  // ----------------------------------------------------------------------
  // Invocation functions for interfaces
  // ----------------------------------------------------------------------

  #for $ifname, $priority, $full in $internal_interfaces:
  void ${class_name}::
    #if $ifname in $internal_interface_param_strs:
    ${ifname}_internalInterfaceInvoke(
        $internal_interface_param_strs[$ifname]
    )
    #else
    ${ifname}_internalInterfaceInvoke()
    #end if
  {

    ComponentIpcSerializableBuffer msg;
    Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

    // Serialize the message ID
    _status = msg.serialize(static_cast<NATIVE_INT_TYPE>(INT_IF_${ifname.upper}));
    FW_ASSERT (
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
    );

    // Fake port number to make message dequeue work
    _status = msg.serialize(static_cast<NATIVE_INT_TYPE>(0));
    FW_ASSERT (
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
    );

    #for $argname, $argtype, $comment, $typeinfo in $internal_interface_args[$ifname]:
      #if $typeinfo == "enum":
    _status = msg.serialize(static_cast<FwEnumStoreType>($argname));
      #else
    _status = msg.serialize($argname);
      #end if
    FW_ASSERT(_status == Fw::FW_SERIALIZE_OK, static_cast<FwAssertArgType>(_status));
    #end for

    // send message
    Os::Queue::QueueBlocking _block =
      #if $full == 'block'
      Os::Queue::QUEUE_BLOCKING;
      #else
      Os::Queue::QUEUE_NONBLOCKING;
      #end if
    Os::Queue::QueueStatus qStatus =
      this->m_queue.send(msg, ${priority},_block);
      #if $full == 'drop'
    if (qStatus == Os::Queue::QUEUE_FULL) {
        this->incNumMsgDropped();
        return;
    }
      #end if
    FW_ASSERT(
        qStatus == Os::Queue::QUEUE_OK,
        static_cast<FwAssertArgType>(qStatus)
    );

  }

  #end for
#end if
#if $has_guarded_ports
  // ----------------------------------------------------------------------
  // Mutex functions for guarded ports
  // ----------------------------------------------------------------------

  void ${class_name} ::
    lock()
  {
    this->m_guardedPortMutex.lock();
  }

  void ${class_name} ::
    unLock()
  {
    this->m_guardedPortMutex.unLock();
  }

#end if
#if $has_serializable_ports:
  // ----------------------------------------------------------------------
  // Call for messages received on serial input ports
  // ----------------------------------------------------------------------

\#if FW_PORT_SERIALIZATION
  #for $instance, $type, $sync, $priority, $full, $role, $max_num in $input_ports:
    #if $type == "Serial":

  void ${class_name} ::
    m_p_${instance}_in(
        Fw::PassiveComponentBase* callComp,
        NATIVE_INT_TYPE portNum,
        Fw::SerializeBufferBase& buffer) {

    FW_ASSERT(callComp);
    ${class_name}* compPtr = static_cast<${class_name}*>(callComp);
    compPtr->${instance}_handlerBase(portNum,buffer);
  }
    #end if
  #end for
  #for $instance, $type, $sync, $priority, $full, $role, $max_num in $input_ports:
    #if $type == "Serial":

  void ${class_name} ::
    ${instance}_handlerBase(
        NATIVE_INT_TYPE portNum,
        Fw::SerializeBufferBase& buffer) {
      #if $sync == "guarded":
     // lock call
    this->lock();
      #end if
      #if $sync == "guarded" or $sync == "sync":
    this->${instance}_handler(portNum,buffer);
      #end if
      #if $sync == "guarded":
    this->unLock();
      #end if
      #if $sync == "async":
    // declare buffer for
    U8 msgBuff[this->m_msgSize];
    Fw::ExternalSerializeBuffer msgSerBuff(msgBuff,this->m_msgSize);

    Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

    // serialize message ID
    _status = msgSerBuff.serialize(
        static_cast<NATIVE_INT_TYPE>(${instance.upper()}_${type.upper()})
    );
    FW_ASSERT (
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
    );

    // serialize port number
    _status = msgSerBuff.serialize(portNum);
    FW_ASSERT (
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
    );

    // serialize buffer
    _status = msgSerBuff.serialize(buffer);
    FW_ASSERT (
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
    );

    // send message
    Os::Queue::QueueBlocking _block =
      #if $full == 'block'
      Os::Queue::QUEUE_BLOCKING;
      #else
      Os::Queue::QUEUE_NONBLOCKING;
      #end if
    Os::Queue::QueueStatus qStatus =
      this->m_queue.send(msgSerBuff, ${priority},_block);
      #if $full == 'drop'
    if (qStatus == Os::Queue::QUEUE_FULL) {
        this->incNumMsgDropped();
        return;
    }
      #end if
    FW_ASSERT(
        qStatus == Os::Queue::QUEUE_OK,
        static_cast<FwAssertArgType>(qStatus)
    );

    #end if
  }
    #end if
  #end for
\#endif

#end if
#if len($message_calls_typed) > 0:
  // ----------------------------------------------------------------------
  // Calls for invocations received on typed input ports
  // ----------------------------------------------------------------------

  #for $instance, $type, $sync, $priority, $full, $role, $max_num in $message_calls_typed:
    #set $params = $port_param_strs[$instance]
    #set $void_params = $params == "void"
    #set $return_type = $port_return_type_strs[$instance]
    #set $void_return_type = $return_type[:4] == "void"
    #set $args = $port_arg_strs[$instance]
  ${return_type}${class_name} ::
    m_p_${instance}_in(
        Fw::PassiveComponentBase* callComp,
    #if $void_params
        NATIVE_INT_TYPE portNum
    #else:
        NATIVE_INT_TYPE portNum,
        $params
    #end if
    )
  {
    FW_ASSERT(callComp);
    ${class_name}* compPtr = static_cast<${class_name}*>(callComp);
    #if $void_params and $void_return_type:
    compPtr->${instance}_handlerBase(portNum);
    #else if $void_params
    return compPtr->${instance}_handlerBase(portNum);
    #else if $void_return_type:
    compPtr->${instance}_handlerBase(portNum, $args);
    #else:
    return compPtr->${instance}_handlerBase(portNum, $args);
    #end if
  }

  #end for
  // ----------------------------------------------------------------------
  // Port handler base-class functions for typed input ports
  // ----------------------------------------------------------------------

  #for $instance, $type, $sync, $priority, $full, $role, $max_num in $message_calls_typed:
    #set $params = $port_param_strs[$instance]
    #set $void_params = $params == "void"
    #set $return_type = $port_return_type_strs[$instance]
    #set $void_return_type = $return_type[:4] == "void"
    #set $args = $port_arg_strs[$instance]
  ${return_type}${class_name} ::
    #if $void_params:
    ${instance}_handlerBase(NATIVE_INT_TYPE portNum)
    #else:
    ${instance}_handlerBase(
        NATIVE_INT_TYPE portNum,
        $params
    )
    #end if
  {

    // Make sure port number is valid
    FW_ASSERT(portNum < this->getNum_${instance}_InputPorts(),static_cast<FwAssertArgType>(portNum));
    #if not $void_return_type:
    ${return_type} retVal;
    #end if

    #if $sync == "async":
    // Call pre-message hook
      #if $void_params:
    ${instance}_preMsgHook(portNum);
      #else:
    ${instance}_preMsgHook(
        portNum,
        $args
    );
      #end if

    ComponentIpcSerializableBuffer msg;
    Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

    _status = msg.serialize(
        static_cast<NATIVE_INT_TYPE>(${instance.upper()}_${type.upper()})
    );
    FW_ASSERT (
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
    );

    _status = msg.serialize(portNum);
    FW_ASSERT (
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
    );

      #set $args = $port_args[$instance]
      #for $arg_name, $arg_type, $arg_comment, $arg_modifier, $arg_enum, $non_const_arg_type in $args:
    // Serialize argument $arg_name
        #if $arg_modifier == '*':
    _status = msg.serialize(static_cast<void *>($arg_name));
        #else if $arg_enum == 'ENUM':
    _status = msg.serialize(static_cast<FwEnumStoreType>($arg_name));
        #else:
    _status = msg.serialize($arg_name);
        #end if
    FW_ASSERT(
        _status == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(_status)
    );

      #end for

    // send message
    Os::Queue::QueueBlocking _block =
      #if $full == 'block'
      Os::Queue::QUEUE_BLOCKING;
      #else
      Os::Queue::QUEUE_NONBLOCKING;
      #end if
    Os::Queue::QueueStatus qStatus =
      this->m_queue.send(msg, ${priority},_block);
      #if $full == 'drop'
    if (qStatus == Os::Queue::QUEUE_FULL) {
        this->incNumMsgDropped();
        return;
    }
      #end if
    FW_ASSERT(
        qStatus == Os::Queue::QUEUE_OK,
        static_cast<FwAssertArgType>(qStatus)
    );

    #else:
      #if $sync == "guarded":
    // Lock guard mutex before calling
    this->lock();

      #end if
    // Down call to pure virtual handler method implemented in Impl class
      #if $void_params and $void_return_type
    this->${instance}_handler(portNum);
      #else if $void_params:
    retVal = this->${instance}_handler(portNum);
      #else if $void_return_type
    this->${instance}_handler(portNum, $args);
      #else:
    retVal = this->${instance}_handler(portNum, $args);
      #end if

      #if $sync == "guarded":
    // Unlock guard mutex
    this->unLock();

      #end if
      #if not $void_return_type:
    return retVal;

      #end if
    #end if
  }

  #end for
#end if
#if len($pre_message_hooks) > 0:
  // ----------------------------------------------------------------------
  // Pre-message hooks for async input ports
  // ----------------------------------------------------------------------

  #for $instance, $type, $sync, $priority, $role, $max_num in $pre_message_hooks:
    #set $params = $port_param_strs[$instance]
  void ${class_name} ::
    #if $type == "Serial":
    ${instance}_preMsgHook(
        NATIVE_INT_TYPE portNum,
        Fw::SerializeBufferBase &Buffer
    )
    #else if $params == "void":
    ${instance}_preMsgHook(NATIVE_INT_TYPE portNum)
    #else:
    ${instance}_preMsgHook(
        NATIVE_INT_TYPE portNum,
        $params
    )
    #end if
  {
    // Default: no-op
  }

  #end for
#end if
#if ($kind == "queued") or ($kind == "active"):
  // ----------------------------------------------------------------------
  // Message dispatch method for active and queued components. Called
  // by active component thread or implementation code for queued components
  // ----------------------------------------------------------------------

  Fw::QueuedComponentBase::MsgDispatchStatus ${class_name} ::
    doDispatch()
  {
#if $needs_msg_size:
    U8 msgBuff[this->m_msgSize];
    Fw::ExternalSerializeBuffer msg(msgBuff,this->m_msgSize);
#else
    ComponentIpcSerializableBuffer msg;
#end if
    NATIVE_INT_TYPE priority = 0;

  #if ($kind == "active")
    Os::Queue::QueueStatus msgStatus = this->m_queue.receive(msg,priority,Os::Queue::QUEUE_BLOCKING);
    FW_ASSERT(
        msgStatus == Os::Queue::QUEUE_OK,
        static_cast<FwAssertArgType>(msgStatus)
    );
  #else
    Os::Queue::QueueStatus msgStatus = this->m_queue.receive(msg,priority,Os::Queue::QUEUE_NONBLOCKING);
    if (Os::Queue::QUEUE_NO_MORE_MSGS == msgStatus) {
      return Fw::QueuedComponentBase::MSG_DISPATCH_EMPTY;
    } else {
      FW_ASSERT(
          msgStatus == Os::Queue::QUEUE_OK,
          static_cast<FwAssertArgType>(msgStatus)
      );
    }
  #end if

    // Reset to beginning of buffer
    msg.resetDeser();

    NATIVE_INT_TYPE desMsg = 0;
    Fw::SerializeStatus deserStatus = msg.deserialize(desMsg);
    FW_ASSERT(
        deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(deserStatus)
    );

    MsgTypeEnum msgType = static_cast<MsgTypeEnum>(desMsg);

    if (msgType == ${name.upper()}_COMPONENT_EXIT) {
      return MSG_DISPATCH_EXIT;
    }

    NATIVE_INT_TYPE portNum = 0;
    deserStatus = msg.deserialize(portNum);
    FW_ASSERT(
        deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(deserStatus)
    );

    switch (msgType) {

  #for $instance, $type, $sync, $priority, $full, $role, $max_num in $input_ports:
    #if $sync == "async" and $role != "Cmd":
      // Handle async input port $instance
      case ${instance.upper()}_${type.upper()}: {

      #set $args = $port_args[$instance]
      #for $arg_name, $arg_type, $arg_comment, $arg_modifier, $arg_enum, $non_const_arg_type in $args
        // Deserialize argument $arg_name
        #if $arg_modifier == '*':
        $non_const_arg_type *$arg_name;
        void* ${arg_name}PtrTemp;
        deserStatus = msg.deserialize(${arg_name}PtrTemp);
        $arg_name = static_cast<$arg_type*>(${arg_name}PtrTemp);
        #else if $arg_enum == "ENUM"
        $non_const_arg_type $arg_name;
        FwEnumStoreType ${arg_name}Int = 0;
        deserStatus = msg.deserialize(${arg_name}Int);
        $arg_name = static_cast<$arg_type>(${arg_name}Int);
        #else
        $non_const_arg_type $arg_name;
        deserStatus = msg.deserialize($arg_name);
        #end if
        FW_ASSERT(
            deserStatus == Fw::FW_SERIALIZE_OK,
            static_cast<FwAssertArgType>(deserStatus)
        );

      #end for
      #if $type == "Serial":
        // Deserialize serialized buffer into new buffer
        U8 handBuff[this->m_msgSize];
        Fw::ExternalSerializeBuffer serHandBuff(handBuff,this->m_msgSize);
        deserStatus = msg.deserialize(serHandBuff);
        FW_ASSERT(
            deserStatus == Fw::FW_SERIALIZE_OK,
            static_cast<FwAssertArgType>(deserStatus)
        );
        this->${instance}_handler(portNum, serHandBuff);
      #else:
        #set $args = $port_arg_strs[$instance]
        // Call handler function
        #if $args == "":
        this->${instance}_handler(portNum);
        #else:
        this->${instance}_handler(
            portNum,
            $args
        );
        #end if
      #end if

        break;

      }

    #end if
  #end for
  #for $mnemonic, $opcodes, $sync, $priority, $full, $comment in $commands:
    #if $sync == "async":
      #if len($opcodes) == 1
      // Handle command $mnemonic
      case CMD_${mnemonic.upper()}: {
      #else
        #set $inst = 0
        #for $opcode in $opcodes
      case CMD_${mnemonic.upper()}_${inst}:
           #set $inst = $inst + 1
        #end for
      {
      #end if
        // Deserialize opcode
        FwOpcodeType opCode = 0;
        deserStatus = msg.deserialize(opCode);
        FW_ASSERT (
            deserStatus == Fw::FW_SERIALIZE_OK,
            static_cast<FwAssertArgType>(deserStatus)
        );

        // Deserialize command sequence
        U32 cmdSeq = 0;
        deserStatus = msg.deserialize(cmdSeq);
        FW_ASSERT (
            deserStatus == Fw::FW_SERIALIZE_OK,
            static_cast<FwAssertArgType>(deserStatus)
        );

        // Deserialize command argument buffer
        Fw::CmdArgBuffer args;
        deserStatus = msg.deserialize(args);
        FW_ASSERT (
            deserStatus == Fw::FW_SERIALIZE_OK,
            static_cast<FwAssertArgType>(deserStatus)
        );

        // Reset buffer
        args.resetDeser();

      #set $args = $command_args[$mnemonic]
      #for $arg_name, $arg_type, $arg_comment, $arg_enum in $args:
        // Deserialize argument $arg_name
        $arg_type $arg_name;
        #if $arg_enum == "enum"
        FwEnumStoreType ${arg_name}Int = 0;
        deserStatus = args.deserialize(${arg_name}Int);
        $arg_name = static_cast<${arg_type}>(${arg_name}Int);
        #else
        deserStatus = args.deserialize($arg_name);
        #end if
        if (deserStatus != Fw::FW_SERIALIZE_OK) {
          if (this->m_${CmdStatus_Name}_OutputPort[0].isConnected()) {
            this->cmdResponse_out(
                opCode,
                cmdSeq,
                Fw::CmdResponse::FORMAT_ERROR
            );
          }
          // Don't crash the task if bad arguments were passed from the ground
          break;
        }

      #end for
        // Make sure there was no data left over.
        // That means the argument buffer size was incorrect.
\#if FW_CMD_CHECK_RESIDUAL
        if (args.getBuffLeft() != 0) {
          if (this->m_${CmdStatus_Name}_OutputPort[0].isConnected()) {
            this->cmdResponse_out(opCode,cmdSeq,Fw::CmdResponse::FORMAT_ERROR);
          }
          // Don't crash the task if bad arguments were passed from the ground
          break;
        }
\#endif
        // Call handler function
      #if len($args) == 0:
        this->${mnemonic}_cmdHandler(opCode, cmdSeq);
      #else
        this->${mnemonic}_cmdHandler(
            opCode,
            cmdSeq,
            $command_args_str($args)
        );
      #end if

        break;

      }

    #end if
  #end for
  #for $ifname, $priority, $full in $internal_interfaces:
      // Handle internal interface $ifname
      case INT_IF_${ifname.upper()}: {
    #set $args = $internal_interface_args[$ifname]
    #set $args_str = $internal_interface_args[$ifname]

    #for $arg_name, $arg_type, $comment, $typeinfo in $args:
        $arg_type $arg_name;
      #if $typeinfo == "enum"
        FwEnumStoreType ${arg_name}Int = 0;
        deserStatus = msg.deserialize(${arg_name}Int);
        $arg_name = static_cast<${arg_type}>(${arg_name}Int);
      #else
        deserStatus = msg.deserialize($arg_name);
      #end if

        // Internal interfaces should always deserialize
        FW_ASSERT(
            Fw::FW_SERIALIZE_OK == deserStatus,
            static_cast<FwAssertArgType>(deserStatus)
        );

    #end for
        // Make sure there was no data left over.
        // That means the buffer size was incorrect.
        FW_ASSERT(
            msg.getBuffLeft() == 0,
            static_cast<FwAssertArgType>(msg.getBuffLeft())
        );

        // Call handler function
        this->${ifname}_internalInterfaceHandler($internal_interface_args_str($args));

        break;

      }

  #end for
      default:
        return MSG_DISPATCH_ERROR;

    }

    return MSG_DISPATCH_OK;

  }

#end if
#if $namespace_list != None
 #for $namespace in $reversed($namespace_list)
} // end namespace $namespace
 #end for
#end if
