# FppTest/typed_tests

This directory contains the following type-parameterized test suites for 
C++ code generated by the FPP autocoder.

* `ArrayTest`: Tests an array class
* `EnumTest`: Tests an enum class
* `PortTest`: Tests typed-to-typed, typed-to-serial, serial-to-typed, and 
serial-to-serial port connections
* `StringTest`: Tests string classes, i.e., subclasses of `Fw::StringBase`.

**Note on the StringTest suite:**
In an earlier version of the C++ back end, FPP generated string classes.
In that version, `StringTest` suite was used to provide code coverage for those
classes.
The code generation strategy for strings has changed, and FPP no longer generates
string classes.
However, we have retained the `StringTest` suite.
It can be used to test other string implementations, e.g., the string
implementations in `Fw/Types`.

## Instantiating a Test Suite

To use a type-parameterized test suite, instantiate it with a list of types:

```c++
#include "FppTest/typed_tests/TestSuite.hpp"

using TestTypes = ::testing::Types<
    Type1,
    Type2,
    Type3
>;
INSTANTIATE_TYPED_TEST_SUITE_P(InstanceName, 
                               TestSuite, 
                               TestTypes);
```

## Implementing Specializations

In addition to instantiating the test suite, you may also need to implement some
explicit specializations for template functions if the behavior of your class
differs from the provided default implementation.

### `EnumTest` Suite

- `getDefaultValue()`: Returns the default value of an enum type. The default
implementation returns 0.

  ```c++
  // Function signature
  template <typename EnumType>
  typename EnumType::T FppTest::Enum::getDefaultValue();
  ```

- `getValidValue()`: Returns a random valid enum value. The default implementation
assumes the values of the enum have been implicitly defined, i.e. it returns
a value in the interval `[0, EnumType::NUM_CONSTANTS-1]`.

  ```c++
  // Function signature
  template <typename EnumType>
  typename EnumType::T FppTest::Enum::getValidValue();
  ```

- `getInvalidValue()`: Returns an random invalid enum value. The default
implementation assumes the values of the enum have been implicitly defined,
i.e. it returns a value either in the interval `[min, -1]` (if the serial
representation type is signed) or in the interval
`[EnumType::NUM_CONSTANTS, max]`, where `min` and `max` are the minimum
and maximum values of the serial representation type, respectively.

  ```c++
  // Function signature
  template <typename EnumType>
  typename EnumType::T FppTest::Enum::getInvalidValue();
  ```

### `ArrayTest` Suite

The following functions MUST be implemented for your array type!

- `setTestVals()`: Sets test values for an array. There is no default
implementation, so this function must be implemented for your array type!
In addition, these test values must be different from the default values.

  ```c++
  // Function signature
  template <typename ArrayType>
  void FppTest::Array::setTestVals
      (typename ArrayType::ElementType (&a)[ArrayType::SIZE]);
  ```

- `getMultiElementConstructedArray()`: Returns an array constructed using its
multiple element constructor. There is no default implementation, so this
function must be implemented for your array type!

  ```c++
  // Function signature
  template <typename ArrayType>
  ArrayType FppTest::Array::getMultiElementConstructedArray
      (typename ArrayType::ElementType (&a)[ArrayType::SIZE]);
  ```

The following functions may or may not need to be implemented:

- `setDefaultVals()`: Sets the default values for an array. The default
implementation is empty (i.e. the values are either zero-initialized or 
default-initialized).

  ```c++
  // Function signature
  template <typename ArrayType>
  void FppTest::Array::setDefaultVals
      (typename ArrayType::ElementType (&a)[ArrayType::SIZE]);
  ```

- `getSerializedSize()`: Returns the serialized size of an array. The default
implementation returns the `SERIALIZED_SIZE` of the array type. In particular,
this function will need to be implemented for arrays containing string values.

  ```c++
  // Function signature
  template <typename ArrayType>
  U32 FppTest::Array::getSerializedSize
      (typename ArrayType::ElementType (&a)[ArrayType::SIZE]);
  ```

## Example

For example, to use the `ArrayTest` suite with array types `U32Array`, an array
of three U32 values, and `F32Array`, an array of four F32 values:

```c++
#include "FppTest/typed_tests/ArrayTest.hpp"

// Instantiate the test suite with a list of types
using ArrayTypes = ::testing::Types<
    U32Array,
    F32Array
>;
INSTANTIATE_TYPED_TEST_SUITE_P(ExampleInstance, 
                               ArrayTest, 
                               ArrayTypes);

// Explicit specializations for setTestVals()
template <>
void FppTest::Array::setTestVals<U32Array>
    (U32Array::ElementType (&a)[U32Array::SIZE]) {
    for (U32 i = 0; i < U32Array::SIZE; i++) {
        a[i] = i;
    }
}

template <>
void FppTest::Array::setTestVals<F32Array>
    (F32Array::ElementType (&a)[F32Array::SIZE]) {
    for (U32 i = 0; i < F32Array::SIZE; i++) {
        a[i] = static_cast<F32>(i);
    }
}

// Explicit specializations for getMultiElementConstructedArray()
template<>
U32Array FppTest::Array::getMultiElementConstructedArray<U32Array>
    (U32Array::ElementType (&a)[U32Array::SIZE]) {
    return U32Array(a[0], a[1], a[2]);
}

template<>
F32Array FppTest::Array::getMultiElementConstructedArray<F32Array>
    (F32Array::ElementType (&a)[F32Array::SIZE]) {
    return F32Array(a[0], a[1], a[2], a[3]);
}
```

