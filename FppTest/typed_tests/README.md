# FppTest/typed_tests

This directory contains the following type-parametrized test suites for 
C++ code generated by the FPP autocoder.

* `EnumTest`: Tests an enum class
* `ArrayTest`: Tests an array class
* `StringTest`: Tests a nested string class within an array of struct class
* `PortTest`: Tests typed-to-typed, typed-to-serial, serial-to-typed, and 
serial-to-serial port connections

## Instantiating a Test Suite

To use a type-parametrized test suite, instantiate it with a list of types:

```c++
#include "FppTest/typed_tests/TestSuite.hpp"

using TestTypes = ::testing::Types<
    Type1,
    Type2,
    Type3
>;
INSTANTIATE_TYPED_TEST_SUITE_P(InstanceName, 
                               TestSuite, 
                               TestTypes);
```

## Implementing Specializations

In addition to instantiating the test suite, you may also need to implement some
explicit specializations for template functions if the behavior of your class
differs from the provided default implementation.

### `EnumTest` Suite

- `getDefaultValue()`: Returns the default value of an enum type. The default
implementation returns 0.

  ```c++
  // Function signature
  template <typename EnumType>
  typename EnumType::T FppTest::Enum::getDefaultValue();
  ```

- `getValidValue()`: Returns a random valid enum value. The default implementation
assumes the values of the enum have been implicitly defined, i.e. it returns
a value in the interval `[0, EnumType::NUM_CONSTANTS-1]`.

  ```c++
  // Function signature
  template <typename EnumType>
  typename EnumType::T FppTest::Enum::getValidValue();
  ```

- `getInvalidValue()`: Returns an random invalid enum value. The default
implementation assumes the values of the enum have been implicitly defined,
i.e. it returns a value either in the interval `[min, -1]` (if the serial
representation type is signed) or in the interval
`[EnumType::NUM_CONSTANTS, max]`, where `min` and `max` are the minimum
and maximum values of the serial representation type, respectively.

  ```c++
  // Function signature
  template <typename EnumType>
  typename EnumType::T FppTest::Enum::getInvalidValue();
  ```

### `ArrayTest` Suite

The following functions MUST be implemented for your array type!

- `setTestVals()`: Sets test values for an array. There is no default
implementation, so this function must be implemented for your array type!
In addition, these test values must be different from the default values.

  ```c++
  // Function signature
  template <typename ArrayType>
  void FppTest::Array::setTestVals
      (typename ArrayType::ElementType (&a)[ArrayType::SIZE]);
  ```

- `getMultiElementConstructedArray()`: Returns an array constructed using its
multiple element constructor. There is no default implementation, so this
function must be implemented for your array type!

  ```c++
  // Function signature
  template <typename ArrayType>
  ArrayType FppTest::Array::getMultiElementConstructedArray
      (typename ArrayType::ElementType (&a)[ArrayType::SIZE]);
  ```

The following functions may or may not need to be implemented:

- `setDefaultVals()`: Sets the default values for an array. The default
implementation is empty (i.e. the values are either zero-initialized or 
default-initialized).

  ```c++
  // Function signature
  template <typename ArrayType>
  void FppTest::Array::setDefaultVals
      (typename ArrayType::ElementType (&a)[ArrayType::SIZE]);
  ```

- `getSerializedSize()`: Returns the serialized size of an array. The default
implementation returns the `SERIALIZED_SIZE` of the array type. In particular,
this function will need to be implemented for arrays containing string values.

  ```c++
  // Function signature
  template <typename ArrayType>
  U32 FppTest::Array::getSerializedSize
      (typename ArrayType::ElementType (&a)[ArrayType::SIZE]);
  ```

### `StringTest` Suite

- `getSize()`: Returns the size of a string type. The default implementation
returns the default string size of 80.

  ```c++
  // Function signature
  template <typename StringType>
  U32 FppTest::String::getSize();
  ```

## Example

For example, to use the `ArrayTest` suite with array types `U32Array`, an array
of three U32 values, and `F32Array`, an array of four F32 values:

```c++
#include "FppTest/typed_tests/ArrayTest.hpp"

// Instantiate the test suite with a list of types
using ArrayTypes = ::testing::Types<
    U32Array,
    F32Array
>;
INSTANTIATE_TYPED_TEST_SUITE_P(ExampleInstance, 
                               ArrayTest, 
                               ArrayTypes);

// Explicit specializations for setTestVals()
template <>
void FppTest::Array::setTestVals<U32Array>
    (U32Array::ElementType (&a)[U32Array::SIZE]) {
    for (U32 i = 0; i < U32Array::SIZE; i++) {
        a[i] = i;
    }
}

template <>
void FppTest::Array::setTestVals<F32Array>
    (F32Array::ElementType (&a)[F32Array::SIZE]) {
    for (U32 i = 0; i < F32Array::SIZE; i++) {
        a[i] = static_cast<F32>(i);
    }
}

// Explicit specializations for getMultiElementConstructedArray()
template<>
U32Array FppTest::Array::getMultiElementConstructedArray<U32Array>
    (U32Array::ElementType (&a)[U32Array::SIZE]) {
    return U32Array(a[0], a[1], a[2]);
}

template<>
F32Array FppTest::Array::getMultiElementConstructedArray<F32Array>
    (F32Array::ElementType (&a)[F32Array::SIZE]) {
    return F32Array(a[0], a[1], a[2], a[3]);
}
```

