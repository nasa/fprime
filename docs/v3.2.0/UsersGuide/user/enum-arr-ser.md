# Data Types and Data Structures: Primitive Types, Enums, Arrays, and Serializables

This guide will describe the types available in F´.  F´ defines both useful short names for primitive types as well as
a set of autocoded complex types.  The types describe here are available to both the flight software and the ground
system unless otherwise noted. Included in this document:

- [Primitive Types](#primitive-types)
- [Polymorphic Type](#polymorphic-type)
- [Complex Types](#complex-types)
    - [Enums](#enums)
    - [Arrays](#arrays)
    - [Serializables](#serializables)
    - [C++ Classes](c-classes)
- [Conclusion](#conclusion)

# Primitive Types

F´ provides convenient type names for C/C++ primitive types. These are established to simplify the writing of F´ code
across multiple systems as well as give an exact definition for each variable used. These types are described in the
following table and are available to both the ground system, events, channels, and commands, and the software itself.

| F´ Type | C/C++ Type | Description             |
|---------|------------|-------------------------|
| BOOL    | bool       | C++ boolean             |
| I8      | int8_t     | signed 8-bit integer    |
| I16     | int16_t    | signed 16-bit integer   |
| I32     | int32_t    | signed 32-bit integer   |
| U8      | uint8_t    | unsigned 8-bit integer  |
| U16     | uint16_t   | unsigned 16-bit integer |
| U32     | uint32_t   | unsigned 32-bit integer |
| F32     | float      | 32-bit floating point   |
| F64     | double     | 64-bit floating point   |
| NATIVE_INT_TYPE  | int           | architecture dependent integer |
| NATIVE_UINT_TYPE | unsigned int  | architecture dependent unsigned integer |
| POINTER_CAST     |               | integer of sufficient size to store a pointer for the architecture |

**Note:** C/C++ types come from `stdint.h` and `stdbool.h`.  The last three types above are not of set size but are
architecture-dependent. Should a project's architecture not support all these types, see:
[Configuring F´: Architecture Supported Primitive Types](../dev/configuring-fprime.md#architecture-supported-primitive-types)

## Polymorphic Type

F´ defines a type for use by the user that can represent any of the primitive types using the same storage space. This
is similar to a C `union` defined with fields of each above type.

### Setting Polymorphic Values

The PolyType object can have a value assigned to it via the constructor or the *equals* operator:

```
PolyType myInt(123)
PolyType myFloat;
myFloat = 123.03
```

### Getting Polymorphic Values

The value stored in the PolyType object can be retrieved in two ways:

1)  Cast the object to the type of the value:
```
U32 val = (U32)pt;
```
6)  Use the get() method:
```
U32 val;
pt.get(val);
```

In both cases, if the type being retrieved does not match the stored
type, the code will assert.

### Checking Polymorphic Values

The PolyType instance has isXXX functions for checking what type is being stored, where XXX is the name of the type.

```
PolyType p(123);
if (p.isU32()) {
    ...
}
```

## Complex Types

The F´ framework supports several types of auto-generated complex types that can be used in the system, including use
in software, command, event, and channel types, and even with the F´ ground system. These types are:

1. Enums: defined enumeration of values
2. Arrays: fixed-length containers of other types
3. Serializable: defined composition of other types akin to a C++ `struct`/`class`

These can all be designed and used in the modeling of F´ and the C++ implementation is autogenerated.

### Enums

Enums are a fixed set of values that can be referred to by name, but are stored and transmitted as an integer type. The
auto-generator produces a class to wrap the type providing convenience functions.

### Arrays

Arrays are fixed-length containers of other types. They must be type-homogeneous but can store any other single type.

### Serializables

Serializables are field-value compositions of other types. They can be type-heterogeneous and may contain any other type
as a value. The autocoder will generate a class with accessor methods for the fields. See the full specification for
the serializable XML: [F´ XML Specifications: Serializables](../dev/xml-specification.md#serializable)

### C++ Classes

When interacting only in the software and not within the F´ design layer, nor with the ground system the user may use
arbitrary C++ `class`/`struct` types. If these types are to be passed through a port invocation as an argument, they
should be defined as subclasses of the `Fw::Serializable` and define `serialize` and `deserialize` methods to be called
to perform the serialization.

## Conclusion

F´ supports many different types, including autocoded complex types.