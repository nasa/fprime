<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>F´ Flight Software - C/C++ Documentation: A Tour of the Source Tree</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">F´ Flight Software - C/C++ Documentation<span id="projectnumber">&#160;devel</span>
   </div>
   <div id="projectbrief">A framework for building embedded system applications to NASA flight quality standards.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('md_fprime_2docs_2documentation_2user-manual_2overview_2source-tree.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">A Tour of the Source Tree</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md460"></a></p>
<p>The following directories constitute the demonstration code. The directories are a mix of tools, framework code, and demonstration code. Details on each module can be seen in the docs/sdd.md (or html) subdirectory. When the code generator is run in a particular directory, it will generate files with the suffixes Ac.hpp and Ac.cpp. These files are not described since they are considered build products. They are automatically incorporated into the build by the build system. The following files in Table 1 are produced by the code generator.</p>
<p><b>Table 1.</b> Files produced by the code generator.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Source   </th><th class="markdownTableHeadNone">Generates   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">&lt;Name&gt;SerializableAi.xml   </td><td class="markdownTableBodyNone">&lt;Name&gt;SerializableAc.hpp(.cpp)   </td><td class="markdownTableBodyNone">Autocoded serializable files    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">&lt;Name&gt;PortAi.xml   </td><td class="markdownTableBodyNone">&lt;Name&gt;PortAc.hpp(.cpp)   </td><td class="markdownTableBodyNone">Autocoded port files    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">&lt;Name&gt;ComponentAi.xml   </td><td class="markdownTableBodyNone">&lt;Name&gt;ComponentAc.hpp(.cpp)   </td><td class="markdownTableBodyNone">Autocoded component files    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">&lt;Name&gt;TopologyAi.xml   </td><td class="markdownTableBodyNone">&lt;Name&gt;TopologyAc.hpp(.cpp)   </td><td class="markdownTableBodyNone">Autocoded topology files   </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md461"></a>
Autocoders</h1>
<p>The Autocoders directory contains the scripts that are used to generate source for the components. It is implemented as a set of Python 2.x scripts that process the XML files used to describe the various entities in the system. The directory also contains the C language version of the hierarchical state machine (HSM) framework that has been flown on several missions at JPL. The HSM is not needed by the framework or the code generation, but is available for use by developers writing component adaptations if they wish to use HSM for implementing state machines. Developers do not need to study the implementation of the autocoder in order to utilize it. The following directories are of interest to developers:</p>
<h2><a class="anchor" id="autotoc_md462"></a>
Templates</h2>
<p>This directory has examples of the XML files that the developer would write for each entity in the system. Each file will be covered in detail in subsequent sections. Their function in the architecture is described in the architecture document. The files are as follows:</p>
<ul>
<li>Example2SerializableAi.xml—An example of a serializable type</li>
<li>ExampleSerializableAi.xml—An example of a more complicated serializable type</li>
<li>ExamplePortAi.xml—An example of a port type</li>
<li>AnotherPortAi.xml—A second port definition</li>
<li>ExampleComponentAi.xml—An example of a component type</li>
<li><a class="el" href="_example_type_8hpp.html">ExampleType.hpp</a>(.cpp)—Not XML, but an example of a user-written serializable</li>
<li><a class="el" href="_example_component_impl_8hpp.html">ExampleComponentImpl.hpp</a>(.cpp)—An example of a user-written component class</li>
</ul>
<p>The user can copy these files and use them as a basis for their own XML files.</p>
<h1><a class="anchor" id="autotoc_md463"></a>
Docs</h1>
<p>The Docs directory contains documentation related to the design and usage of the F′ framework.</p>
<h1><a class="anchor" id="autotoc_md464"></a>
Fw</h1>
<p>The <a class="el" href="namespace_fw.html">Fw</a> directory is the location of framework code and base classes. This code should not be modified (with one exception, see Cfg in Section 5.3.1) by developers using the framework. The code generation relies on the types declared to construct the entities in the architecture.</p>
<h2><a class="anchor" id="autotoc_md465"></a>
config</h2>
<p>The config directory contains header files used to configure various properties of the architecture. The developer can modify the file to tune the architecture for the requirements of a particular deployment environment. The contents are described in Section 9.</p>
<p>The file AcConstants.fpp contains a set of values for variables used in the code generation. Using this file allows component features like opcodes and port numbers to be changed without modifying the component FPP itself.</p>
<h2><a class="anchor" id="autotoc_md466"></a>
Types</h2>
<p>The <a class="el" href="namespace_types.html">Types</a> directory contains basic types and other base classes used in the architecture, as shown in Table 2.</p>
<p><b>Table 2.</b> <a class="el" href="namespace_types.html">Types</a> directory files.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">File   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="_basic_types_8hpp.html" title="C++ header for working with basic fprime types.">BasicTypes.hpp</a>   </td><td class="markdownTableBodyNone">Defines portable built-in data types and common macros    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="_assert_8hpp.html">Assert.hpp</a>(.cpp)   </td><td class="markdownTableBodyNone">Defines macros to declare an assertion in C++ code    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">CAssert.hpp   </td><td class="markdownTableBodyNone">Defines macros to declare an assertion in C code    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="_string_type_8hpp.html">StringType.hpp</a>(.cpp)   </td><td class="markdownTableBodyNone">Declares a string base class    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="_serializable_8hpp.html">Serializable.hpp</a>(.cpp)   </td><td class="markdownTableBodyNone">Declares the serializable base classes and helper functions    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="_poly_type_8hpp.html">PolyType.hpp</a>(.cpp)   </td><td class="markdownTableBodyNone">Describes a serializable polymorphic type class that can be used to uniformly store different types    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="_string_8hpp.html">String.hpp</a>(.cpp)   </td><td class="markdownTableBodyNone">A fixed length string available for general usage if the developer does not wish to write one    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="_internal_interface_string_8hpp.html">InternalInterfaceString.hpp</a>(.cpp)   </td><td class="markdownTableBodyNone">A string class used by internal interfaces when a string argument is specified   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md467"></a>
Obj</h2>
<p>The Obj directory contains class declarations and implementations for the root base class in the architectural framework. FwObjBase.hpp contains the declaration for the object base class. In addition, it contains a declaration for an object registry class. An object registry is an optional feature that allows all objects to be registered as they are created. It is a way to keep track of which objects have been created as well as perform some common actions such as printing a string representation of each object. Components and ports use the object class as a base class. Table 3 lists the files and their descriptions.</p>
<p><b>Table 3.</b> Obj directory files.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">File   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="_obj_base_8hpp.html" title="Declarations for Fw::ObjBase and Fw::ObjRegistry.">ObjBase.hpp</a>(.cpp)   </td><td class="markdownTableBodyNone">Declaration for object base class    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="_simple_obj_registry_8hpp.html" title="Class declaration for a simple object registry.">SimpleObjRegistry.hpp</a>(.cpp)   </td><td class="markdownTableBodyNone">An implementation of a simple object registry: This registry simply stores created object pointers in an array and calls their toString() method when asked.   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md468"></a>
Port</h2>
<p>The Port directory contains the base classes for ports. Table 4 lists the files and their descriptions.</p>
<p><b>Table 4.</b> Port directory files.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">File   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="_port_base_8hpp.html">PortBase.hpp</a>(.cpp)   </td><td class="markdownTableBodyNone">Port base class; contains methods and attributes common to all ports    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">InputPort.hpp(.cpp)   </td><td class="markdownTableBodyNone">Input port base class that is derived from port base class; contains methods and attributes common to all input ports    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">OutputPort.hpp(.cpp)   </td><td class="markdownTableBodyNone">Output port base class that is derived from port base class; contains methods and attributes common to all output ports    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="_input_serialize_port_8hpp.html">InputSerializePort.hpp</a>(.cpp)   </td><td class="markdownTableBodyNone">Input serialize port class: Typed output ports can be connected to input serialize ports. The typed output port will serialize its arguments prior to invoking the port.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="_output_serialize_port_8hpp.html">OutputSerializePort.hpp</a>(.cpp)   </td><td class="markdownTableBodyNone">Output serialize port class: Output serialize ports can be connected to typed input port. The serialize port passes the typed port a buffer representing the serialized arguments, which the typed port deserializes.   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md469"></a>
Comp</h2>
<p>The Comp directory contains the class declarations for the various kinds of components. These classes act as base classes for components created by the code generation and are not directly used by developers. Table 5 lists the files and their descriptions.</p>
<p><b>Table 5.</b> Comp directory files.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">File   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="_passive_component_base_8hpp.html">PassiveComponentBase.hpp</a>(.cpp)   </td><td class="markdownTableBodyNone">The base class for unthreaded passive components: These components have no thread of execution associated with them. This class derives from the object base class.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="_queued_component_base_8hpp.html">QueuedComponentBase.hpp</a>(.cpp)   </td><td class="markdownTableBodyNone">The base class for queued components: These components have a message queue but no thread. It is derived from the passive component base class.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="_active_component_base_8hpp.html">ActiveComponentBase.hpp</a>(.cpp)   </td><td class="markdownTableBodyNone">The base class for active components: Active components have a thread of execution as well as a message queue. It is derived from the queued component class.   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md470"></a>
Cmd</h2>
<p>This Cmd directory contains XML and class declarations used to generate code for command interfaces to components. The XML generates port classes in the normal way via the code generator. The code generator then uses those generated classes as special command input ports for components that define commands in their component XML. Since the ports themselves are generated in the same way as any other port, they can be used by developers in other components that process commands, such as command dispatchers. Table 6 lists the files and their descriptions.</p>
<p><b>Table 6.</b> Cmd directory files.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">File   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">CmdPortAi.xml   </td><td class="markdownTableBodyNone">XML description of a command port    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">CmdResponsePortAi.xml   </td><td class="markdownTableBodyNone">XML description of a command response port    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">CmdRegPortAi.xml   </td><td class="markdownTableBodyNone">XML description of a command registration port    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="_cmd_arg_buffer_8hpp.html">CmdArgBuffer.hpp</a>(.cpp)   </td><td class="markdownTableBodyNone">A class used by the command port that is a data buffer containing the serialized form of the command arguments    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="_cmd_string_8hpp.html">CmdString.hpp</a>(.cpp)   </td><td class="markdownTableBodyNone">A string class used by the command code generator for string arguments    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="_cmd_packet_8hpp.html">CmdPacket.hpp</a>(.cpp)   </td><td class="markdownTableBodyNone">A class representing an encoded command packet that contains a command opcode and arguments: The code generator does not depend on this class, so it can be modified or not used.   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md471"></a>
Tlm</h2>
<p>This Tlm directory contains XML and class declarations used to generate code for channelized telemetry interfaces for components. Channelized telemetry has historically been a snapshot in time of a set of data. Every value of that data is not necessarily stored permanently, but is sampled. The XML generates port classes in the normal way via the code generator. The code generator then uses those generated classes as special telemetry output ports for components needing telemetry. Since the ports themselves are generated in the same way as any other port, they can be used by developers in other components that process telemetry, such as a telemetry buffer for downlinking telemetry. Table 7 lists the files and their descriptions.</p>
<p><b>Table 7.</b> Tlm directory files.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">File   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">TlmPortAi.xml   </td><td class="markdownTableBodyNone">XML description of a telemetry port    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="_tlm_buffer_8hpp.html">TlmBuffer.hpp</a>(.cpp)   </td><td class="markdownTableBodyNone">A data buffer class that represents the serialized form of the telemetry channel    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="_tlm_string_8hpp.html">TlmString.hpp</a>(.cpp)   </td><td class="markdownTableBodyNone">A string class used by the telemetry code generator when a string is the telemetry channel    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="_tlm_packet_8hpp.html">TlmPacket.hpp</a>(.cpp)   </td><td class="markdownTableBodyNone">A notional class representing an encoded telemetry packet that contains a telemetry channel identifier and serialized value: The code generator does not depend on this class, so it can be modified or not used.   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md472"></a>
Log</h2>
<p>This Log directory contains XML and class declarations used to generate code logging (event) interfaces for components. Developer implementation code sends log events to capture all the events of interest in a system as they happen. Other components serve to store events for forwarding to a ground interface or test software. An XML definition for telemetry ports is defined, which the code generator then uses as special logging output ports for components. Since the ports themselves are generated in the same way as any other port, they can be used by developers in other components that process logging, such as a logging history. Table 8 lists the files and their descriptions.</p>
<p><b>Table 8.</b> Log directory files.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">File   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">LogPortAi.xml   </td><td class="markdownTableBodyNone">XML description of a logging port    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">LogTextPortAi.xml   </td><td class="markdownTableBodyNone">XML description of an optional text logging port: This port generates a string representing the logged event. The code generator generates code to use both kinds of logging ports, but the text log can be disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="_log_buffer_8hpp.html">LogBuffer.hpp</a>(.cpp)   </td><td class="markdownTableBodyNone">A data buffer class that represents the serialized form of the log entry    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="_log_string_8hpp.html">LogString.hpp</a>(.cpp)   </td><td class="markdownTableBodyNone">A string class used by the log code generator when a string is the telemetry channel    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="_text_log_string_8hpp.html">TextLogString.hpp</a>(.cpp)   </td><td class="markdownTableBodyNone">A string class used by the text log interface to pass strings    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="_log_packet_8hpp.html">LogPacket.hpp</a>(.cpp)   </td><td class="markdownTableBodyNone">A notional class representing an encoded log packet that contains a log entry identifier and serialized set of values: The code generator does not depend on this class, so it can be modified or not used.   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md473"></a>
Prm</h2>
<p>This Prm directory contains XML and class declarations used to generate parameter interfaces for components. Parameters are values are meant to be stored in nonvolatile storage that affect various properties of the software. Parameters are loaded at run time and given to components on request. An XML definition for a parameter port is used by the code generator to create special parameter output ports for components. Since the ports themselves are generated in the same way as any other port, they can be used by developers in other components that provide parameters. Table 9 lists the files and their descriptions.</p>
<p><b>Table 9.</b> Prm directory files.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">File   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">PrmPortAi.xml   </td><td class="markdownTableBodyNone">XML description of a parameter port    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="_prm_buffer_8hpp.html">PrmBuffer.hpp</a>(.cpp)   </td><td class="markdownTableBodyNone">A data buffer that represents a serialized parameter    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="_prm_string_8hpp.html">PrmString.hpp</a>(.cpp)   </td><td class="markdownTableBodyNone">A string class used by the parameter code generator when a string is the parameter value    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">PrmPacket.hpp(.cpp)   </td><td class="markdownTableBodyNone">A notional class representing an encoded parameter packet that contains a parameter identifier and serialized value: The code generator does not depend on this class, so it can be modified or not used.   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md474"></a>
Time</h2>
<p>This Time directory contains XML and class declarations used to generate time interfaces for components. The time interface port is created by the code generator as a source of time for time-tagging telemetry samples and log events. Since the ports themselves are generated in the same way as any other port, they can be used by developers in other components that provide time from whatever sources are present in the system. Table 10 lists the files and their descriptions.</p>
<p><b>Table 10.</b> Time directory files.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">File   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">TimePortAi.xml   </td><td class="markdownTableBodyNone">XML description of a time port    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="_time_8hpp.html">Time.hpp</a>   </td><td class="markdownTableBodyNone">A class containing a time value that represents the time when the port was invoked   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md475"></a>
Com</h2>
<p>This Com directory contains definitions for a communication port. This port could be used as an interface to components that send and receive data to ground or test software. Table 11 lists the files and their descriptions.</p>
<p><b>Table 11.</b> Com directory files.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">File   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">ComPortAi.xml   </td><td class="markdownTableBodyNone">XML description of a communication port    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="_com_buffer_8hpp.html">ComBuffer.hpp</a>(.cpp)   </td><td class="markdownTableBodyNone">A data buffer class used to represent a packet of serialized communication data    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="_com_packet_8hpp.html">ComPacket.hpp</a>(.cpp)   </td><td class="markdownTableBodyNone">A data packet class representing data from one of the telemetry or command types: The specific packet types are derived classes.   </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md476"></a>
Svc</h1>
<p>The intent of this directory is to provide a set of components implementing services that would be useful for a flight application. The service layer in software is traditionally the layer that provides the mechanism for executing the software and managing data. The components, ports, and other types are examples of how the architecture can be applied. The component example implementations are very simple; flight versions would most likely be more sophisticated. The way development is done is that the developer will define the components and their properties in XML. The code generator will generate C++ classes that encapsulate the features of the component. The developer will then write a class that derives from those generated classes and implement the port methods. For these directories, each file will not be described, but a higher-level description of what each directory contains will be given instead. The descriptions are as follows.</p>
<h2><a class="anchor" id="autotoc_md477"></a>
ActiveLogger</h2>
<p>This directory contains a component XML description and implementation for an active component that accepts serialized log events. The input port accepting log entries puts them in a message queue for the component thread. The component thread calls the port handler in the derived class written by the developer. In this case, the handler simply takes the log entry, serializes it into a communications buffer, and sends it out via the output communications port. There are commands for filtering the event levels.</p>
<h2><a class="anchor" id="autotoc_md478"></a>
ActiveRateGroup</h2>
<p>This directory contains a component implementation of an active rate group. In real-time programming, a rate group is a thread of execution that does a sequential set of operations that execute cyclically and are required to be complete by a certain deadline. In this case, this component provides the thread for the rate group and sequentially calls a set of output ports that would be connected to other components doing the specific operations that are required.</p>
<h2><a class="anchor" id="autotoc_md479"></a>
CmdDispatcher</h2>
<p>This directory contains an implementation of a command dispatcher. The commands are received in serialized form from another component. The command identifier (opcode) is deserialized, and an output port is looked up that is matched with that identifier. The port is then invoked with the serialized command arguments. After executing the command, the component responds back to the dispatcher via a response port and reports on the outcome of the command. The dispatcher then calls a status output port if connected in the event there was something else such as a sequencer waiting for a result. During initialization, a command registration port is called by components to match the identifier with the port that the component is executing commands from. The component also implements some NO_OP commands.</p>
<h2><a class="anchor" id="autotoc_md480"></a>
CmdSequencer</h2>
<p>This directory contains an implementation of a command sequencer. A sequence file uploaded to the system contains a set of commands that are executed in order with optional time points. The sequencer waits until the current command is complete before executing the next in the sequence. A failed command terminates the sequence.</p>
<h2><a class="anchor" id="autotoc_md481"></a>
CmdRecord</h2>
<p>This directory specifies the port used to pass command buffers between the SequenceFileLoader and the SequenceRunner components.</p>
<h2><a class="anchor" id="autotoc_md482"></a>
Cycle</h2>
<p>This directory specifies the port used to drive the ActiveRateGroup components. The port passes a time stamp indicating when the cycle started.</p>
<h2><a class="anchor" id="autotoc_md483"></a>
Fatal</h2>
<p>The directory specifies a port used to pass a notification that a FATAL event has occurred. It is currently produced by the ActiveLogger component when it receives a FATAL event from a component.</p>
<h2><a class="anchor" id="autotoc_md484"></a>
GndIf</h2>
<p>The directory contains just the XML definition of a component that could be used to send and receive communications packets. The uplink port would be connected to the command dispatcher for executing commands, and the downlink port would be connected by components collecting downlink telemetry like logs and channelized data. A derived class implementing a TCP/IP socket version can be seen in SocketGndIf.</p>
<h2><a class="anchor" id="autotoc_md485"></a>
Hub</h2>
<p>A hub is a pattern for communicating between computing nodes. A hub component is a component that contains input and output serialized ports. As mentioned in Section 5.3.4, when a typed port is connected to a serialized port, the port arguments are serialized and passed as a data buffer to the serialized port. Likewise, when a data buffer is sent from a serialized port to a typed port, the data are deserialized back into the typed arguments of the port. A hub component takes the serialized data passed to it and sends it via a communication channel to a hub on a remote node. The remote hub takes that data and calls a serialized output port connected to a typed port of the same type as the original port. That allows components to be interconnected across computing nodes without any modifications to the components themselves. This particular hub is implemented as an active hub, which means that the serial buffers from the incoming ports are put in a message queue and then sent out to the DataOut ports on the thread of the component. The data output ports are in the form of a generic com buffer. The data output ports would be connected to a component that manages the communication hardware. Likewise, incoming data on the DataIn port is queued for the component thread, which sends it out via a serialized output port.</p>
<h2><a class="anchor" id="autotoc_md486"></a>
LinuxTime</h2>
<p>This component is an adaptation of the time source component specified in the Time directory. In this case, it is a time source that makes a Linux system call for the Linux demo.</p>
<h2><a class="anchor" id="autotoc_md487"></a>
PassiveConsoleTextLogger</h2>
<p>This is an adaptation of the PassiveTextLogger component that simply takes the text version of the log and prints it to the standard output.</p>
<h2><a class="anchor" id="autotoc_md488"></a>
PassiveRateGroup</h2>
<p>This is a rate group with the same implementation as the active rate group in Section 5.4.2, with the exception that the component does not have a thread. The thread that calls the input run port will be used to call all the output ports. This component is not currently used in the reference application.</p>
<h2><a class="anchor" id="autotoc_md489"></a>
PassiveTextLogger</h2>
<p>This defines a base class for a component that prints the text version of events. It executes on the thread of the caller. The implementation classes are elsewhere, such as PassiveConsoleTextLogger.</p>
<h2><a class="anchor" id="autotoc_md490"></a>
PolyDb</h2>
<p>This component implements a database of PolyType entries. The intent is for this to be used as a database of values being used by different components in the system. Some components submit new values they have gathered, and other components retrieve the ones they use.</p>
<h2><a class="anchor" id="autotoc_md491"></a>
PolyIf</h2>
<p>This contains the definition for a PolyPort, or a port that passes a PolyType. It is used to set and get values for the PolyDb component.</p>
<h2><a class="anchor" id="autotoc_md492"></a>
PrmDb</h2>
<p>This component implements storage for parameters. It implements the framework setPrm and getPrm ports. Parameter values are stored as a table based on parameter ID. It reads a file during initialization that contains the parameter values and loads them into memory. Subsequent calls to getPrm will get the loaded file. Parameter values in the components can be updated by command and saved to PrmDb. The PrmDb component can be commanded to save the updated values to a file.</p>
<h2><a class="anchor" id="autotoc_md493"></a>
RateGroupDriver</h2>
<p>This component takes a primary clock tick in the system and divides it down to drive output ports. Constructor arguments define the divisors for each port. The output ports are meant to be connected to the input ports of rate groups to drive them at the correct rate.</p>
<h2><a class="anchor" id="autotoc_md494"></a>
Sched</h2>
<p>This directory contains the definition of a scheduler port that is used by the rate group components and rate group members.</p>
<h2><a class="anchor" id="autotoc_md495"></a>
SequenceFileLoader</h2>
<p>This directory contains a component that loads a set of command buffers from a file and passes them to the SequenceFileRunner component.</p>
<h2><a class="anchor" id="autotoc_md496"></a>
SequenceRunner</h2>
<p>The directory contains a component that will sequence through a series of command buffers passed through its CmdRecord port.</p>
<h2><a class="anchor" id="autotoc_md497"></a>
SocketGndIf</h2>
<p>This directory contains a notional uplink/downlink component that communicates with ground software via a TCP/IP socket. It would be connected to telemetry sources and the command dispatcher.</p>
<h2><a class="anchor" id="autotoc_md498"></a>
Time</h2>
<p>This directory contains the XML definition for the time source base class. A time source is necessary for time-tagging the telemetry and log events in components. Various implementations that derive from this base class will provide time.</p>
<h2><a class="anchor" id="autotoc_md499"></a>
Tlm</h2>
<p>This directory defines a passive telemetry storage component base class. It has an input port for the telemetry buffers sent by components. It has an output port to send the telemetry packets to a ground interface component like the one in Section 5.4.21. It has a scheduler input port so that it can be executed periodically on a rate group to send the stored telemetry to the ground interface.</p>
<h2><a class="anchor" id="autotoc_md500"></a>
TlmChan</h2>
<p>This directory contains an adaptation of the Tlm base class in Section 5.4.23. In this adaptation, the telemetry is stored in an array of telemetry buffers based on the telemetry ID. The storage is double-buffered. When the scheduler port is invoked, the component switches the active array to non-active and starts copying the non-active array to the packet output port. If incoming telemetry calls happen during the copy operation, they are placed in the active array.</p>
<h1><a class="anchor" id="autotoc_md501"></a>
Os</h1>
<p>This directory contains classes that abstract operating system features. This allows the components that are code generated to not be dependent on a particular operating system. The architecture is dependent on these classes. The subdirectories contain implementations of the class for different operating systems. Not all operating systems will implement all classes. The classes are as follows.</p>
<h2><a class="anchor" id="autotoc_md502"></a>
Task</h2>
<p>This class represents a task (AKA thread) in an operating system process. It has methods for starting, ending, waiting, and suspending tasks. This class is used by active components.</p>
<h2><a class="anchor" id="autotoc_md503"></a>
Queue</h2>
<p>This class represents a message queue. It has methods for creating, writing to, reading from, and destroying queues. This class is used by queued components.</p>
<h2><a class="anchor" id="autotoc_md504"></a>
Mutex</h2>
<p>This class represents a mutex. It is used to guard critical sections of data and code. It is used by components that have guarded ports (see architecture description).</p>
<h2><a class="anchor" id="autotoc_md505"></a>
File</h2>
<p>This class represents a file. It is used to abstract away various operating system implementations of file I/O.</p>
<h1><a class="anchor" id="autotoc_md506"></a>
Drv</h1>
<p>The <a class="el" href="namespace_drv.html">Drv</a> directory contains some hypothetical device driver components and types. It is part of the example code. The architecture does not depend on the source code in this directory. There is no particular significance to the name; rather, it was selected to represent how a developer might organize their code. The subdirectories are as follows.</p>
<h2><a class="anchor" id="autotoc_md507"></a>
BlockDriver</h2>
<p>This represents a hardware driver that accepts buffers of data to send to a device, and sends buffers that it receives from the device. Since there is no real hardware behind the driver, the driver takes any incoming data buffers from the input port and sends them out the output port.</p>
<h2><a class="anchor" id="autotoc_md508"></a>
DataTypes</h2>
<p>This directory contains the port and data buffer types used by the driver and components using the driver.</p>
<h1><a class="anchor" id="autotoc_md509"></a>
Ref</h1>
<p>This directory contains a reference application. Components here represent what an adapter might do when writing application-specific logic. An adapter would use the framework layers, drivers, and services that are meant to be reusable, along with application components for a particular task.</p>
<h2><a class="anchor" id="autotoc_md510"></a>
SendBuffApp</h2>
<p>This passive component represents a part of the application that sends data to a consumer. It runs periodically in a rate group and sends a packet upon command. It uses the driver described in Section 5.6.1.</p>
<h2><a class="anchor" id="autotoc_md511"></a>
RecvBuffApp</h2>
<p>This active component represents a part of the application that receives data from a sender, in this case SendBuffApp. It receives a buffer from the driver.</p>
<h2><a class="anchor" id="autotoc_md512"></a>
Top</h2>
<p>This is the topology module. This is where all the components are instantiated and connected together, and the active components are started. It is also the location of the C <a class="el" href="_fpp_test_2array_2_main_8cpp.html#a0ddf1224851353fc92bfbff6f499fa97">main()</a> function entry point. Each deployment (see Section 6.2) will have a module similar to this. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
