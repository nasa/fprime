<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>F´ Flight Software - C/C++ Documentation: Constructing the F´ Topology</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">F´ Flight Software - C/C++ Documentation<span id="projectnumber">&#160;devel</span>
   </div>
   <div id="projectbrief">A framework for building embedded system applications to NASA flight quality standards.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('md_fprime_2docs_2documentation_2user-manual_2framework_2building-topology.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Constructing the F´ Topology</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md233"></a></p>
<p>!!! note For a hands-on walk-through of build topologies, please see: <a class="el" href="md_fprime_2docs_2documentation_2tutorials_2index.html">Tutorials</a></p>
<p>The executing software consists of a set of interconnected components executing on the threads of the active components or driven by other events in the system such as hardware interrupts or timing sources. This section will describe the steps necessary to get the software up and running.</p>
<p>This guide discusses:</p>
<ul>
<li>Instantiating the Components</li>
<li>Initializing the Components</li>
<li>Interconnecting the Components</li>
<li>Registering Commands</li>
<li>Loading Parameters</li>
<li>Starting Active Components</li>
</ul>
<h1><a class="anchor" id="autotoc_md234"></a>
Instantiating the Components</h1>
<p>The constructors in the component base classes have been designed so that the components can be instantiated using whatever memory model the developer wishes. They can be created statically, on the heap, or on the stack. As described in Section 6.7.8.1, the constructor has either a name argument or none at all. The developer’s derived class constructors may have extra arguments that are particular to that application. If classes are declared statically, the developer should keep in mind uncertainties about execution order.</p>
<h1><a class="anchor" id="autotoc_md235"></a>
Initializing the Components</h1>
<p>As discussed in Section 6.8.2, each component has an init() call that initializes the component base classes. This call should be made after instantiating the components. For queued and active components, the queue size is passed. The queue should be sized based on an understanding of task priorities and message traffic between the components.</p>
<h1><a class="anchor" id="autotoc_md236"></a>
Interconnecting the Components</h1>
<p>The components in the software are interconnected by connecting the ports of the components together. Ports are connected by passing pointers to input ports to the output ports that are calling them. Methods are generated in the component base classes to get input port pointers and pass them to output ports. The following sections describe the connections of different port types.</p>
<h2><a class="anchor" id="autotoc_md237"></a>
Interface Ports</h2>
<p>Interface ports are the regular ports that are used to connect components together. For each port type and name on a component, the method naming scheme is as follows:</p>
<p>Get input port pointer:</p>
<blockquote class="doxtable">
<p>&zwj;&lt;PortType&gt;* get_&lt;port name&gt;_InputPort(NATIVE_INT_TYPE
portNum); </p>
</blockquote>
<p>where</p>
<blockquote class="doxtable">
<p>&zwj;&lt;PortType&gt; = The full port type specified in the data_type attribute in the definition of the port in the component XML.</p>
<p>&lt;port name&gt; = The name of the port in the name attribute of the port definition. </p>
</blockquote>
<p>The portNum argument to the method should be set to zero if there is only one instance of the port.</p>
<p>Set output port pointer:</p>
<p>The value of the input pointer retrieved via the method in the last section is given to an output port of the same type by calling:</p>
<blockquote class="doxtable">
<p>&zwj;void set_&lt;port name&gt;_OutputPort(NATIVE_INT_TYPE portNum, &lt;PortType&gt;*port); </p>
</blockquote>
<p>where</p>
<blockquote class="doxtable">
<p>&zwj;&lt;PortType&gt; = The full port type specified in the data_type attribute in the definition of the port in the component XML.</p>
<p>&lt;port name&gt; = The name of the port in the name attribute of the port definition. </p>
</blockquote>
<p>The portNum argument to the method should be set to zero if there is only one instance of the port.</p>
<p>There is a second overloaded version of the method to set an output port when the input port being passed to it is a serialized port:</p>
<blockquote class="doxtable">
<p>&zwj;void set_&lt;port name&gt;_OutputPort(NATIVE_INT_TYPE portNum,
Fw::InputSerializePort *port); </p>
</blockquote>
<h2><a class="anchor" id="autotoc_md238"></a>
Command Ports</h2>
<p>As discussed in Section 6.6.4, the code generator will create the correct set of command-related ports for a component that has commands defined. For that component, the functions used to get or set command-related port pointers have standard names. The names are as follows:</p>
<p>Get command input port:</p>
<blockquote class="doxtable">
<p>&zwj;Fw::InputFwCmdPort* get_CmdDisp_InputPort(); </p>
</blockquote>
<p>Set command status port:</p>
<blockquote class="doxtable">
<p>&zwj;void set_CmdStatus_OutputPort(Fw::InputCmdResponse_Port* port); </p>
</blockquote>
<p>Set command registration port:</p>
<blockquote class="doxtable">
<p>&zwj;void set_CmdReg_OutputPort(Fw::InputCmdRegPort* port); </p>
</blockquote>
<p>For the component(s) that are connected to those ports, they would use the normal methods for accessing the port pointers as described in the last section.</p>
<h2><a class="anchor" id="autotoc_md239"></a>
Telemetry Ports</h2>
<p>The standard port accessor functions for telemetry are as follows:</p>
<p>Set telemetry output ports:</p>
<blockquote class="doxtable">
<p>&zwj;void set_Tlm_OutputPort(Fw::InputTlmPort* port); </p>
</blockquote>
<p>Set time output ports:</p>
<blockquote class="doxtable">
<p>&zwj;void set_Time_OutputPort(Fw::InputTimePort* port); </p>
</blockquote>
<h2><a class="anchor" id="autotoc_md240"></a>
Event Logging Ports</h2>
<p>The standard port accessor functions for logging events are as follows:</p>
<p>Set logging output ports:</p>
<blockquote class="doxtable">
<p>&zwj;void set_Log_OutputPort(Fw::InputLogPort* port);</p>
<p>void set_TextLog_OutputPort(Fw::InputFwLogTextPort* port); </p>
</blockquote>
<p>Set time output ports:</p>
<blockquote class="doxtable">
<p>&zwj;void set_Time_OutputPort(Fw::InputFwTimePort* port); </p>
</blockquote>
<p>Note that the set_Time_OutputPort() call is shared with the telemetry ports. It can be called once for both.</p>
<h2><a class="anchor" id="autotoc_md241"></a>
Parameter Ports</h2>
<p>The standard port accessor functions for parameters is as follows:</p>
<blockquote class="doxtable">
<p>&zwj;void set_ParamGet_OutputPort(Fw::InputFwPrmGetPort* port);</p>
<p>void set_ParamSet_OutputPort(Fw::InputFwPrmSetPort* port); </p>
</blockquote>
<h1><a class="anchor" id="autotoc_md242"></a>
Registering Commands</h1>
<p>The pattern for dispatching commands is for a user-implemented command dispatch component to connect an output command port to the input command port for each component servicing commands. Internally, the dispatcher would map the set of opcodes for a particular component to the port that is connected to that component. To aid that process, the code generator creates a command registration function when there are commands specified for a component. It takes as an argument the port number on the dispatcher component that is connected to the component’s command port. The registration port should be connected to the dispatcher’s registration port as described in Section 6.8.3.2. Then the regCommands() method can be called in the component, which will invoke the registration port for each of the opcodes defined. This method should be called for each component that has commands.</p>
<h1><a class="anchor" id="autotoc_md243"></a>
Loading Parameters</h1>
<p>Section 6.8.3.5 describes how to connect a parameter output port to a component providing parameter storage. After the two components are connected, the base class method loadParameters() can be called. That method will request the values of all parameters for that component via the parameter port. From then on, they will be available to the implementation class for use. Although it is common to only read parameters at software initialization, there is nothing that prevents a re-read after the software has started running by invoking the loadParameters() call again in the event that the parameter storage was updated.</p>
<h1><a class="anchor" id="autotoc_md244"></a>
Starting Active Components</h1>
<p>The last action in constructing the topology is to start the tasks for any active components. The start() method is found in the ActiveComponentBase base class in Fw/Comp/FwActiveComponentBase.hpp. Table 22 provides the arguments and their meanings.</p>
<p><b>Table 22.</b> Active component start() arguments.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Meaning    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">identifier   </td><td class="markdownTableBodyNone">A thread-independent value that is used to identify activities of the thread. Should be unique in the system.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">priority   </td><td class="markdownTableBodyNone">The execution priority of the task: 0 = low priority, 255 = high priority.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">stackSize   </td><td class="markdownTableBodyNone">The size of the stack given to the task.   </td></tr>
</table>
<p>As mentioned in Section 6.7.8.3, the functions preamble() and finalizer() will be run once before and after the loop waiting for port invocations. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
