<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>F´ Flight Software - C/C++ Documentation: Core Constructs: Ports, Components, and Topologies</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">F´ Flight Software - C/C++ Documentation<span id="projectnumber">&#160;devel</span>
   </div>
   <div id="projectbrief">A framework for building embedded system applications to NASA flight quality standards.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('md_fprime_2docs_2documentation_2user-manual_2overview_2port-comp-top.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Core Constructs: Ports, Components, and Topologies</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md441"></a></p>
<p><b>Ports</b>, <b>Components</b>, and <b>Topologies</b> represent the building blocks of an F´ system. From these pieces, a modular system is constructed to complete the objective of the embedded system. This document includes:</p>
<ul>
<li>Ports: F´ Communication</li>
<li>Components: F´ Modules</li>
<li>Topology: F´ Application</li>
<li>Conclusion</li>
</ul>
<h1><a class="anchor" id="autotoc_md442"></a>
Ports: F´ Communication</h1>
<p>Although F´ is primarily decomposed into a set of <b>Components</b>, it is often the port that a user of F´ must understand first. This is because the set of ports a <b>Component</b> defines is the external (or public) interface of that <b>Component</b> in an F´ system. Thus it is essential to understand and design these <b>Ports</b> correctly.</p>
<h2><a class="anchor" id="autotoc_md443"></a>
Port Characteristics</h2>
<p>Ports are the point of interconnection between <b>Components</b> in the software framework and encapsulate typed interfaces in the architecture. This means that each port definition is of a specific type (e.g. CommandDispatchPort) and can only connect <b>Components</b> defining ports of the same type. When one <b>Component</b> uses a port to communicate with another <b>Component</b> this action is called a port <b>invocation</b>. These port types are known as "data_types" because they represent the data being conveyed across the port.</p>
<p>A port supports passing arguments across the port's connection in order to pass data to the receiving <b>Component</b> of an invocation. Some ports may also return data from the receiving <b>Component</b> to the invoking <b>Component</b>. A port may specify zero or more arguments of any F´ data type or primitive (int, float, U8, etc.). Pointers and references are allowed as arguments to the port as well (for performance purposes), but care should be taken to ensure correct memory management as the ownership of the underlying memory is effectively shared when the port is invoked. The port's type is synonymous with the port invocations' "data_type" when used on a <b>Component</b>.</p>
<p>When using a port, the user specifies directionality. It can represent an input or an output. This direction pertains to the direction of invocation from one originating <b>Component</b> to another and not necessarily the direction of data flow i.e. output ports (invoking out to another <b>Component</b>) can in some cases retrieve data. Multiple output ports can be connected to a single input port implying that at <b>Component</b> responding to a port invocation could be responding to one of a set of invoking <b>Components</b>. <b>Caution:</b> a single output port can be connected to only one input port at a time.</p>
<p>Another aspect of port usage is the synchronous/asynchronous nature of the port. A synchronous port operates like a function call running in the execution context of the invoking <b>Component</b> (i.e. on the invoker's Thread). The synchronous nature of the port along with the directionality is combined in the "kind" when used by the <b>Component</b>.</p>
<p>Finally, a port can be defined as "guarded", which means invocations into the port are limited to a single invocation at a time by a component-wide mutex. This is also combined into the "kind" attribute.</p>
<p><img src="../../../img/core1.png" alt="Port Image" class="inline"/></p>
<p><b>Figure 1. Port connectivity.</b> Ports are connected to ports of the same type. When used by a <em>component</em>, the ports can define directionality. Using <em>serialized ports</em> (see below), serializes the call and passes it to a data buffer such that it can be sent and deserialized anywhere.</p>
<p>When discussing ports, one must be careful to distinguish between the port <b>design</b> and the port instantiation. A port's design is generic specifying its type (name, arguments transported, etc) and when used in a <b>Component</b> is designated as the port's "data_type". The design is careful not to specify its usage by a component (directionality, synchronous/asynchronous nature, guarded/not guarded). This is specified as part of the instantiation of a port when used by a component. This instantiation is specifically part of the <b>Component</b>'s design and not the port's design and is known as the "kind" of port's instantiation.</p>
<h2><a class="anchor" id="autotoc_md444"></a>
A Quick Look at Port Kinds Defined in A Component's Usage</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Port Kind   </th><th class="markdownTableHeadNone">Direction   </th><th class="markdownTableHeadNone">Synchronous / Asynchronous   </th><th class="markdownTableHeadNone">Guarded   </th><th class="markdownTableHeadNone">May Return Data   </th><th class="markdownTableHeadNone">See Diagram   </th><th class="markdownTableHeadNone">Notes    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">output   </td><td class="markdownTableBodyNone">out   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"><code>func4()</code>   </td><td class="markdownTableBodyNone">The input side of a connection defines all port properties.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">sync_input   </td><td class="markdownTableBodyNone">in   </td><td class="markdownTableBodyNone">synchronous   </td><td class="markdownTableBodyNone">no   </td><td class="markdownTableBodyNone">yes   </td><td class="markdownTableBodyNone"><code>func2()</code>   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">async_input   </td><td class="markdownTableBodyNone">in   </td><td class="markdownTableBodyNone">asynchronous   </td><td class="markdownTableBodyNone">no   </td><td class="markdownTableBodyNone">no   </td><td class="markdownTableBodyNone"><code>func1()</code>   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">guarded_input   </td><td class="markdownTableBodyNone">in   </td><td class="markdownTableBodyNone">synchronous   </td><td class="markdownTableBodyNone">yes   </td><td class="markdownTableBodyNone">yes   </td><td class="markdownTableBodyNone"><code>func3()</code>   </td><td class="markdownTableBodyNone">Guarded ports by definition must be synchronous   </td></tr>
</table>
<p>!!! note A port's type (aka data_type) is dependent on the design and usage in the deployment.</p>
<p><img src="../../../img/core2.png" alt="Port Instance Kinds" class="inline"/></p>
<p><b>Figure 2. Port Kinds Used on a Component.</b> For the <em>synchronous port</em>, the call directly invokes derived functions without the use of a queue. For a <em>guarded port</em>, the call directly invokes derived functions, but only after locking a mutex shared by all guarded ports in the component. For an <em>asynchronous port</em>, the call is placed in a queue and dispatched on a thread that empties the queue.</p>
<p>Should the user wish to understand what types of ports are available per component type, please review the section on Port Kinds Available to Each Component Type</p>
<h2><a class="anchor" id="autotoc_md445"></a>
Port Call Serialization</h2>
<p>Serialization on ports take arguments supplied to the port and translates them to a data buffer. The serialized ports are supported by the framework allowing users to send primitive and custom types. Ports can have return valves; however, use is limited to only return data when the component has defined the input port (invoked port) as a synchronous interface, and the port serialization has been disabled since serialization passes a data buffer without returning one.</p>
<p>Serialization takes a specific set of typed values or function arguments and converts them in an architecture-independent way translating them to a data buffer. A port call’s commands and arguments are serialized and placed on message queues in the receiving component. In addition command arguments and telemetry values are passed as serialized buffers so that components that transfer the data can be independent of the definition of the data.</p>
<p>Users can define arbitrary interface argument types and the framework automatically serializes the data for port calls. They can also define complex types in XML where a code generator generates classes that are serializable for use internally, and usable with the F´ supplied ground system.</p>
<h2><a class="anchor" id="autotoc_md446"></a>
Special Serialized Ports</h2>
<p>Serialization ports are special ports that handle serialized buffers without automatically unpacking them. Any output port type can connect to a serialization port input type, and any serialization output port can be connected to any input port type. This allows strongly-typed ports to connect to generic "pass-any-data" serialization ports as shown in Figure 3. For input ports, the calling port detects a connection and serializes arguments. For the output ports, the serialized port calls an interface on the typed port that deserializes arguments. Serialization ports do not support ports with return types. These ports allow serialized data to be passed around by generic components that do not know the type contained. The <a class="el" href="md_fprime_2docs_2documentation_2user-manual_2framework_2hub-pattern.html">Hub pattern</a> often uses serialized ports such that data can be routed across an address-space gap in a generic fashion.</p>
<p><img src="../../../img/core3.png" alt="Serialization Ports" class="inline"/></p>
<p><b>Figure 3. Serialization ports.</b> Input ports input the serialized buffer, while the output ports output the serialized buffer.</p>
<p>Serialization ports are useful for generic storage and communication components that do not need to know the type of data passing through them. This allows the design and implementation of command and data handling (C&amp;DH) components that provide reusability. Tested C&amp;DH components are developed to implement typical non-mission-specific flight functions</p>
<p>See note about usage for <a class="el" href="md_fprime_2docs_2documentation_2user-manual_2overview_2cmd-evt-chn-prm.html">Commands, Events and Telemetry</a>.</p>
<h1><a class="anchor" id="autotoc_md447"></a>
Components: F´ Modules</h1>
<p>The F′ architecture is based on decomposing the system into modules called components. Each component contains a a discrete portion of the system's logic (Figure 10); The component architecture implies usage patterns, as well as usage constraints.</p>
<p><img src="../../../img/core10.png" alt="Component Architecture" class="inline"/></p>
<p><b>Figure 10. Example of F′ component architecture pattern.</b></p>
<p>Components encapsulate behavior and are not aware of other components. They are localized to one compute context with specific interactions with other components using ports. There should be no non-port communication between components. Components are responsible for handling the invocations of ports used in the component. They may also define and handle commands as well as emit telemetry and events.</p>
<p><img src="../../../img/core11.png" alt="Example Component" class="inline"/></p>
<p><b>Figure 11. Encapsulation of Behavior</b> The component handles the port behaviors as well as executes the commands and then produces the telemetry. It does not directly interact with other components.</p>
<h2><a class="anchor" id="autotoc_md448"></a>
Component Types</h2>
<p>There are three types of components: passive, queued, and active. These components allow for different functionality in the system and may use different port input types see below. Each type of component is defined below:</p>
<p><b>Passive component:</b> has no thread and cannot support asynchronous port invocations nor asynchronous commands. Port invocations call into the developer class but execution context is supplied from the invoking component.</p>
<p><b>Active component:</b> has a thread of execution as well as a queue. The thread dispatches port calls from the queue as on the execution context of the thread. Active components may define use port kinds. <b>Caution:</b> Synchronous and guarded port invocations still execute in the execution context of the invoker.</p>
<p><b>Queued component:</b> has no thread but does have a queue. Thus it handles asynchronous commands and port invocations; however, the user must implement at least one synchronous port invocation that unloads and handles the messages on the queue. For this and any other synchronously invocation execution context is supplied by the invoker. <b>Note:</b> this component type is only rarely used. Ensure it is the correct choice for your design.</p>
<h3><a class="anchor" id="autotoc_md449"></a>
A Quick Look at Component Types</h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Component Type   </th><th class="markdownTableHeadNone">Has Queue   </th><th class="markdownTableHeadNone">Has Thread    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Passive Component   </td><td class="markdownTableBodyNone">No   </td><td class="markdownTableBodyNone">No    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Active Component   </td><td class="markdownTableBodyNone">Yes   </td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Queued Component   </td><td class="markdownTableBodyNone">Yes   </td><td class="markdownTableBodyNone">No   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md450"></a>
Division of Component Implementation</h2>
<p>Each component is divided into three classes that each represent a piece of the component's implementation. These three classes are as follows:</p>
<ol type="1">
<li>Core Framework Class: the base class of components defined as part of the framework. A component may inherit from: active, passive, and queued classes. These represent the component types defined above.</li>
<li>Generated Component-Specific Base: this class is the direct descendant of the core framework class and is automatically generated to provide all the implementation for framework features.</li>
<li>Component-Specific Developer Implementation Class: this class inherits from the generated component-specific base class and contains only the user-specific implementation for the component.</li>
</ol>
<p>These are shown in Figure 12.</p>
<p><img src="../../../img/core12.png" alt="Component Class Hierarchy" class="inline"/></p>
<p><b>Figure 12. Example of component class hierarchy.</b></p>
<h2><a class="anchor" id="autotoc_md451"></a>
Port Kinds Available to Each Component Type</h2>
<p>Passive components support synchronous and guarded ports with the execution context supplied by the calling component. There is no queue to support asynchronous ports. Active components support all three port types; however, the active component needs at least one asynchronous port otherwise it would be effectively passive with a superfluous queue and thread.</p>
<p>Queued components also support all three port types; however, the queued component needs at least one synchronous or guarded port as the code and one asynchronous port. A synchronous or guarded port must be defined to unload the internal queue as a queued component does not have a thread to automatically unload the queue. A queued component must define one asynchronous port otherwise it too would effectively be a passive component with an unused queue attached.</p>
<p>Output ports are invoked by calling generated base class functions from the implementation class. The behavior invoked is defined input port side of the connection and thus there are no special restrictions to use output ports.</p>
<h2><a class="anchor" id="autotoc_md452"></a>
Quick Look at Component Types and Supported Ports</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Component Type   </th><th class="markdownTableHeadNone">Output   </th><th class="markdownTableHeadNone">Guarded / Synchronous Ports   </th><th class="markdownTableHeadNone">Asynchronous Ports    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Passive   </td><td class="markdownTableBodyNone">0 or more   </td><td class="markdownTableBodyNone">0 or more   </td><td class="markdownTableBodyNone">Not available    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Queued   </td><td class="markdownTableBodyNone">0 or more   </td><td class="markdownTableBodyNone">1 or more   </td><td class="markdownTableBodyNone">1 or more    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Active   </td><td class="markdownTableBodyNone">0 or more   </td><td class="markdownTableBodyNone">0 or more   </td><td class="markdownTableBodyNone">1 or more   </td></tr>
</table>
<p>!!! note The designer should be aware of how the different calls interact, for example during reentrant port calls guarded ports may deadlock.</p>
<h1><a class="anchor" id="autotoc_md453"></a>
Topology: F´ Application</h1>
<p>Components are instantiated at runtime and then connected through the ports to other components in the system. This graph of interconnected components is known as a topology, as shown in Figure 13. The topology graph is still designed before runtime, but the actual connection of ports happens during the construction and setup phase of runtime F´ software. There should be no code dependencies between the components, only dependencies on port interface types. A component's ability to communicate with other components is enabled through the interconnections specified in the topology. Alternate implementations can therefore easily be swapped, for example with simulation versions.</p>
<p><img src="../../../img/core13.png" alt="Example Topology" class="inline"/></p>
<p><b>Figure 13. Example of a topology.</b></p>
<h1><a class="anchor" id="autotoc_md454"></a>
Conclusion</h1>
<p>F´ is decomposed into a federation of discrete components organized into a system graph. The interconnections in this graph are handled through port calls such that the otherwise independent components can interact with each other. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
