<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>F´ Flight Software - C/C++ Documentation: F´ Implementation Classes</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">F´ Flight Software - C/C++ Documentation<span id="projectnumber">&#160;devel</span>
   </div>
   <div id="projectbrief">A framework for building embedded system applications to NASA flight quality standards.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('md_fprime_2docs_2documentation_2user-manual_2framework_2implementation.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">F´ Implementation Classes</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md282"></a></p>
<p>!!! note for a hands-on walk-through of build topologies, please see: <a class="el" href="md_fprime_2docs_2documentation_2tutorials_2index.html">Tutorials</a></p>
<p>The code generator takes the XML definitions in the previous section and generates C++ base classes. The developer writes classes that derive from those base classes and implements the project-specific logic. For input ports and commands, the base classes declare pure virtual methods for the derived class to implement. If a developer forgets to implement these functions, the compilation of the code will fail. For output ports, telemetry channels, events, and parameters, the base class provides methods for the base class to call.</p>
<p>Depending on the kind of the component, the virtual calls will be made on the thread of the component itself or the thread of a component calling a synchronous or guarded port.</p>
<p>This guide walks through how to use the autocoded setup for:</p>
<ul>
<li>Ports</li>
<li>Commands</li>
<li>Channels/Telemetry</li>
<li>Events</li>
<li>Parameters</li>
</ul>
<p>Advanced topics:</p>
<ul>
<li>Internal Interfaces</li>
<li>Message Pre-Hooks</li>
<li>Initialization Code</li>
</ul>
<h1><a class="anchor" id="autotoc_md283"></a>
Ports</h1>
<h2><a class="anchor" id="autotoc_md284"></a>
Input port calls</h2>
<p>The pure virtual function to implement a port call is derived from the name of the port declaration in the component XML. The function is declared in the protected section of the class and has the following naming scheme:</p>
<blockquote class="doxtable">
<p>&zwj;&lt;port name&gt;_handler(NATIVE_INT_TYPE portNum, &lt;argument list&gt;) = 0; </p>
</blockquote>
<p>where</p>
<blockquote class="doxtable">
<p>&zwj;&lt;port name&gt; = The name given to the port in the name= tag in the port section of the XML.</p>
<p>portNum = If the XML writer has defined multiple ports, this allows the developer to know which port was invoked. The value is the port instance indexed to zero. In the event the “max_number” attribute is not specified (i.e., a single input port), this value will be zero.</p>
<p>&lt;argument_list&gt; = The list of arguments specified in the args section of the port definition XML. </p>
</blockquote>
<h2><a class="anchor" id="autotoc_md285"></a>
Output port calls</h2>
<p>The base class function for outgoing port calls is derived from the name and type of the port declaration in the component XML. The function is declared in the protected section of the class and has the following naming scheme:</p>
<blockquote class="doxtable">
<p>&zwj;&lt;port name&gt;_out(NATIVE_INT_TYPE portNum, &lt;argument list&gt;); </p>
</blockquote>
<p>where</p>
<blockquote class="doxtable">
<p>&zwj;&lt;port name&gt; = The name given to the port in the name= tag in the port section of the XML.</p>
<p>portNum = If XML writer has defined multiple ports, this allows the developer to specify which port to invoke. The value is the port instance indexed to zero. In the event the “max_number” attribute is not specified (i.e., a single output port), this value should be set to zero.</p>
<p>&lt;argument_list&gt; = The list of arguments specified in the args section of the port definition XML. </p>
</blockquote>
<p>The call will invoke the port methods defined on whatever component the component in consideration is interconnected with. If those ports are defined as synchronous or guarded, the other component’s logic will execute on the thread of the call.</p>
<p>If the port is not connected and is called, the code will assert. If the design calls for ports that are optionally connected, the connection status can be checked before calling via this function:</p>
<blockquote class="doxtable">
<p>&zwj;isConnected _&lt;port name&gt;_OutputPort(NATIVE_INT_TYPE portNum); </p>
</blockquote>
<h2><a class="anchor" id="autotoc_md286"></a>
Port number calls</h2>
<p>A method in the base class can be called to get the number of ports available. The method has the following naming scheme:</p>
<blockquote class="doxtable">
<p>&zwj;NATIVE_INT_TYPE getNum_&lt;port name&gt;_&lt;direction&gt;Ports(); </p>
</blockquote>
<p>where</p>
<blockquote class="doxtable">
<p>&zwj;&lt;port name&gt; = The name given to the port in the name= tag in the port section of the XML.</p>
<p>&lt;direction&gt; = The direction of the port, Input or Output. </p>
</blockquote>
<p>The developer can use this to automatically scale the code to the number of ports specified in the XML. If the port output function is called with a portNum value greater than the number of ports minus one, the code will assert.</p>
<h1><a class="anchor" id="autotoc_md287"></a>
Commands</h1>
<p>The pure virtual function to implement a command is derived from the mnemonic in the command declaration in the component XML. The function is declared in the protected section of the class and has the following naming scheme:</p>
<blockquote class="doxtable">
<p>&zwj;&lt;mnemonic&gt;_cmdHandler(FwOpcodeType opcode, U32 cmdSeq, &lt;argument list&gt;) = 0; </p>
</blockquote>
<p>where</p>
<blockquote class="doxtable">
<p>&zwj;&lt;mnemonic&gt; = The mnemonic string of the command given in the mnemonic= tag in the command section of the XML.</p>
<p>&lt;argument_list&gt; = The list of arguments specified in the args section of the command definition XML. </p>
</blockquote>
<p>When the command has been completed, a command response method must be called in the base class to inform the dispatcher of the command that it has completed. That function call is as follows:</p>
<blockquote class="doxtable">
<p>&zwj;void cmdResponse_out(FwOpcodeType opCode, U32 cmdSeq,
Fw::CommandResponse response); </p>
</blockquote>
<p>The opcode and cmdSeq values passed by the function should be passed to the command response function as well as a status indicating the success or failure of a command. The opcode is specified in the XML, and cmdSeq will be set by the command dispatcher to track where the command is in a sequence of commands. If more information about a failure is needed, an event should be specified and called with the additional information (see Section 6.7.4). If a command takes a number of steps and the call to the command dispatch function does not complete the command, the opcode and command sequence should be stored for a later call to the command response function.</p>
<h1><a class="anchor" id="autotoc_md288"></a>
Telemetry</h1>
<p>A telemetry channel is intended to be used for periodically measured data. It is a snapshot in time, and all values may not be permanently recorded and sent to the command and data handling software. The code generator generates a base class function for each telemetry channel defined in the XML. The developer calls this to write a new value of the telemetry being stored. The function is declared in the protected section of the class and has the following naming scheme:</p>
<blockquote class="doxtable">
<p>&zwj;tlmWrite_&lt;channel name&gt;(&lt;type&gt;&amp; arg); </p>
</blockquote>
<p>where</p>
<blockquote class="doxtable">
<p>&zwj;&lt;channel name&gt; = The name given to the port in the name= tag in the channel section of the XML.</p>
<p>&lt;type&gt; = The non-namespace qualified type of the channel as specified in the data_type= tag in the XML. </p>
</blockquote>
<p>The argument is always passed by reference to avoid copying. The call internally adds a timestamp to the value. There is a method getTime() in the base class if the developer wishes to use a time value for other purposes.</p>
<h1><a class="anchor" id="autotoc_md289"></a>
Events</h1>
<p>Events are intermittent and are all recorded to reconstruct a series of actions or events after the fact. The code generator generates a base class function for each event defined in the XML. The developer calls whenever the event to be recorded happens. The function is declared in the protected section of the class and has the following naming scheme:</p>
<blockquote class="doxtable">
<p>&zwj;log_&lt;severity&gt;_&lt;event name&gt;(&lt;event arguments&gt;); </p>
</blockquote>
<p>where</p>
<blockquote class="doxtable">
<p>&zwj;&lt;severity&gt; = The value of the severity attribute in the XML for the event.</p>
<p>&lt;event name&gt; = The name of the event given in the name attribute in the XML.</p>
<p>&lt;event arguments&gt; = The argument list of the event. </p>
</blockquote>
<p>The call internally adds a timestamp to the event. There is a method getTime() in the base class if the developer wishes to use a time value for other purposes.</p>
<h1><a class="anchor" id="autotoc_md290"></a>
Parameters</h1>
<p>Parameters are values that are stored non-volatilely and are ways to influence the behavior of the software without requiring software updates. During initialization, the parameters are retrieved and stored in the component base class for later use be the developer’s derived class. If for some reason the parameters cannot be retrieved, the default value specified in the XML is returned. The function is declared in the protected section of the class and has the following naming scheme:</p>
<blockquote class="doxtable">
<p>&zwj;&lt;parameter type&gt; paramGet_&lt;parameter name&gt;(Fw::ParamValid&amp; valid); </p>
</blockquote>
<p>where</p>
<blockquote class="doxtable">
<p>&zwj;&lt;parameter type&gt; = The type of the parameter specified by the data_type tag in the XML.</p>
<p>&lt;parameter name&gt; = The name of the parameter given in the name attribute in the XML. </p>
</blockquote>
<p>The parameter value is returned by reference to avoid copying the data. The valid value should be checked after the call to see what the status of the parameter value is. Table 21 provides the possible values of the status and their meanings.</p>
<p><b>Table 21.</b> Parameter retrieval status values.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Value   </th><th class="markdownTableHeadNone">Meaning    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Fw::PARAM_UNINIT   </td><td class="markdownTableBodyNone">The code to attempt to retrieve the value was never called. This is most likely an error in forgetting to call the loadParameters() public function for the component during software initialization.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Fw::PARAM_VALID   </td><td class="markdownTableBodyNone">The parameter was successfully retrieved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Fw::PARAM_INVALID   </td><td class="markdownTableBodyNone">The parameter was not successfully retrieved, and no default was specified.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Fw::PARAM_DEFAULT   </td><td class="markdownTableBodyNone">The parameter was not successfully retrieved, but a default was provided.   </td></tr>
</table>
<p>A virtual method is defined in the base class:</p>
<blockquote class="doxtable">
<p>&zwj;void parameterUpdated(FwPrmIdType id); </p>
</blockquote>
<p>By default this method does nothing, but the developer can override the method if the implementation needs a notification of when a parameter value is updated. It is called each time a parameter is updated.</p>
<h1><a class="anchor" id="autotoc_md291"></a>
Internal Interfaces</h1>
<p>When internal interfaces are specified in the component XML, a function is generated that can be called by implementation code to dispatch a message for a message loop. The function has the following name:</p>
<blockquote class="doxtable">
<p>&zwj;&lt;internal interface name&gt;_internalInterfaceInvoke(&lt;arguments&gt;); </p>
</blockquote>
<p>A handler function definition is also defined for the function that will be called when the internal interface message is dispatched. The function has the following name:</p>
<blockquote class="doxtable">
<p>&zwj;&lt;internal interface name&gt;_internalInterfaceHandler(&lt;arguments&gt;); </p>
</blockquote>
<p>The function is defined as a pure virtual to make sure it is implemented.</p>
<h1><a class="anchor" id="autotoc_md292"></a>
Message Pre-hooks</h1>
<p>When asynchronous ports or commands are specified, the code generator defines functions that can be called prior to dispatching the message. This provides a lightweight mechanism to do some work before the message is dispatched. The function is defined as a virtual (not pure) function with a default implementation that is empty. The implementer can override the function with an alternate version.</p>
<p>The function name for ports is as follows:</p>
<blockquote class="doxtable">
<p>&zwj;void &lt;port name&gt;_preMsgHook(NATIVE_INT_TYPE portNum, &lt;port arguments&gt;); </p>
</blockquote>
<p>The values of the port arguments are passed to the function.</p>
<p>The function name for commands is as follows:</p>
<blockquote class="doxtable">
<p>&zwj;void &lt;command mnemonic&gt;_preMsgHook(FswOpcodeType opcode, U32
cmdSeq); </p>
</blockquote>
<p>It does not provide the arguments for the command since they are not extracted until the command message is processed.</p>
<h1><a class="anchor" id="autotoc_md293"></a>
Initialization Code</h1>
<h2><a class="anchor" id="autotoc_md294"></a>
Constructor</h2>
<p>The component framework has the option of storing component names for component interconnection testing and tracing. This is enabled or disabled via the class naming configuration discussed in Section 9.2. The macro that indicates whether or not the naming is enabled is FW_OBJECT_NAMES*.* The developer should define and implement two alternate constructors, one that takes a name argument and one that does not. As seen in the example, the only difference between the two constructor implementations is that the base class constructor needs to be passed the name argument. The user can add any custom constructor code as well, but at this stage, the component base class is not initialized so no port calls should be made.</p>
<h2><a class="anchor" id="autotoc_md295"></a>
Initialization</h2>
<p>Each component base class has an init() function that must be called before interconnecting components. If the component is queued or active, a queue depth argument must be provided. In addition, there is an optional instance argument if the component is going to be instanced more than once. This function can be called from a parallel init() function in the derived class.</p>
<h2><a class="anchor" id="autotoc_md296"></a>
Task Preamble/Finalizer</h2>
<p>Active components provide a preamble prototype for code that can be run once before the thread blocks waiting for port invocations and a finalizer prototype for code that runs when the component exits the message loop. These two functions are called on the thread of the active component. They are declared as virtual functions in C++, so they are not required. The preamble function is named preamble(void) and the finalizer is named finalizer(void). They can be used to do one-time activities such as data structure initialization and cleanup. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
