<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>F´ Flight Software - C/C++ Documentation: Svc::CmdSequencer Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">F´ Flight Software - C/C++ Documentation
   &#160;<span id="projectnumber">NASA-v1.6.0</span>
   </div>
   <div id="projectbrief">A framework for building embedded system applications to NASA flight quality standards.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('_svc_cmd_sequencer_component.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Svc::CmdSequencer Component </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md1622"></a>
Svc::CmdSequencer Component</h1>
<h2><a class="anchor" id="autotoc_md1623"></a>
1 Introduction</h2>
<p>The command sequencer is a component that iterates through a set of commands contained in binary form in a file located in a file system available to the sequencer. A command to the sequencer specifies the file to execute. The file can contain commands that execute immediately, after a delay, or at an absolute time. The sequence will abort if any given command in the sequence returns a failed status.</p>
<h2><a class="anchor" id="autotoc_md1624"></a>
2 Requirements</h2>
<p>The requirements for <code>Svc::CmdSequencer</code> are as follows:</p>
<table class="doxtable">
<tr>
<th>Requirement </th><th>Description </th><th>Verification Method </th><th>Rationale  </th></tr>
<tr>
<td>ISF-CMDS-001 </td><td>The <code>Svc::CmdSequencer</code> component shall read sequence files. </td><td>Unit <a class="el" href="namespace_test.html">Test</a> </td><td>CmdSequencer gets commands from the sequence file. </td></tr>
<tr>
<td>ISF-CMDS-002 </td><td>The <code>Svc::CmdSequencer</code> component shall validate the sequence files with a CRC. </td><td>Unit <a class="el" href="namespace_test.html">Test</a> </td><td>CmdSequencer need to know it has a valid file. </td></tr>
<tr>
<td>ISF-CMDS-003 </td><td>The <code>Svc::CmdSequencer</code> component shall provide a command to validate the sequence file. </td><td>Unit <a class="el" href="namespace_test.html">Test</a> </td><td>Waiting to validate the file only when running it can cause operational issues </td></tr>
<tr>
<td>ISF-CMDS-004 </td><td>The <code>Svc::CmdSequencer</code> component shall cancel the sequence upon receiving a failed command status. </td><td>Unit <a class="el" href="namespace_test.html">Test</a> </td><td>A sequence should not continue if a command fails since subsequent commands may depend on the outcome </td></tr>
<tr>
<td>ISF-CMDS-005 </td><td>The <code>Svc::CmdSequencer</code> component shall provide a command to cancel the existing sequence </td><td>Unit <a class="el" href="namespace_test.html">Test</a> </td><td>Operator should be able to cancel the sequence if it is hung or needs to be stopped. </td></tr>
<tr>
<td>ISF-CMDS-006 </td><td>The <code>Svc::CmdSequencer</code> component shall provide an overall sequence timeout. </td><td>Unit <a class="el" href="namespace_test.html">Test</a> </td><td>Sequencer should quit if a component fails to send a command response </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md1625"></a>
3 Design</h2>
<h3><a class="anchor" id="autotoc_md1626"></a>
3.1 Component Context</h3>
<div class="image">
<img src="img/CmdSequencerIBD.jpg" alt="Component IBD"/>
</div>
<h3><a class="anchor" id="autotoc_md1627"></a>
3.2 Component Interface</h3>
<div class="image">
<img src="img/CmdSequencerBDD.jpg" alt="Component BDD"/>
</div>
<h4><a class="anchor" id="autotoc_md1628"></a>
3.2.1 Port description table</h4>
<table class="doxtable">
<tr>
<th>Port Name</th><th>Type</th><th>Direction</th><th>Usage  </th></tr>
<tr>
<td>cmdRegOut</td><td>Fw::CmdReg&lt;td&gt;output</td><td>Framework command registration </td></tr>
<tr>
<td>cmdIn</td><td>Fw::Cmd&lt;td&gt;input</td><td>Framework command input port </td></tr>
<tr>
<td>cmdResponseOut</td><td>Fw::CmdResponse&lt;td&gt;output</td><td>Framework command status port </td></tr>
<tr>
<td>logOut</td><td>Fw::Log&lt;td&gt;output</td><td>Framework binary log output port </td></tr>
<tr>
<td>LogText</td><td>Fw::LogText&lt;td&gt;output</td><td>Framework text log output port </td></tr>
<tr>
<td>tlmOut</td><td>Fw::Tlm&lt;td&gt;output</td><td>Framework telemetry port </td></tr>
<tr>
<td>timeCaller</td><td>Fw::Time&lt;td&gt;output</td><td>Framework time port </td></tr>
<tr>
<td>pingIn</td><td>Svc::Ping&lt;td&gt;async input</td><td>Input ping call </td></tr>
<tr>
<td>pingOut</td><td>Svc::Ping&lt;td&gt;output</td><td>Reply for ping </td></tr>
<tr>
<td>schedIn</td><td>Svc::Sched&lt;td&gt;async input</td><td>Scheduler input - timed commands will be checked </td></tr>
<tr>
<td>comCmdOut</td><td>Fw::Com&lt;td&gt;output</td><td>Sends command buffers for each command in sequence </td></tr>
<tr>
<td>cmdResponseIn</td><td>Fw::CmdResponse&lt;td&gt;asyc input</td><td>Received status of last dispatched command </td></tr>
<tr>
<td>seqRunIn</td><td>Svc::CmdSeqIn&lt;td&gt;async input</td><td>Receives requests for running sequences from other components </td></tr>
<tr>
<td>seqDone</td><td>Fw::CmdResponse&lt;td&gt;output</td><td>outputs status of sequence run; meant to be used with <code>seqRunIn</code> </td></tr>
</table>
<h4><a class="anchor" id="autotoc_md1629"></a>
3.2.2 Command Handlers</h4>
<p><a class="anchor" id="invalid"></a></p><h5>3.2.2.1 CS_Validate</h5>
<p>The <code>CS_Validate</code> command will validate that the format and checksum of a sequence file are correct without executing any commands in the file. This allows operators to validate a file prior to executing it. <a class="anchor" id="invalid"></a></p><h5>3.2.2.2 CS_Run</h5>
<p>The <code>CS_Run</code> command will execute a sequence. If a prior sequence is still running, it will be canceled. If a command returns a failed status, the sequence will be aborted. <a class="anchor" id="invalid"></a></p><h5>3.2.2.3 CS_Cancel</h5>
<p>The <code>CS_Cancel</code> command will cancel an existing sequence. If there is no sequence currently executing, the command will emit a warning event but not fail. <a class="anchor" id="invalid"></a></p><h5>3.2.2.4 CS_Manual</h5>
<p>The <code>CS_Manual</code> command will put the sequencer in a manual stepping mode, where the commands will be advanced by the <code>CS_Step</code> command. After entering this mode, the operator should issue a <code>CS_Run</code> command to load the sequence. In this mode, the sequence will be validated and loaded, but will not execute any commands until receiving the <code>CS_Start</code> command <a class="anchor" id="invalid"></a></p><h5>3.2.2.5 CS_Start</h5>
<p>The <code>CS_Start</code> command will execute the first command in the sequence in manual mode. <a class="anchor" id="invalid"></a></p><h5>3.2.2.6 CS_Step</h5>
<p>The <code>CS_Step</code> command will execute subsequent commands after receiving the <code>CS_Start</code> command. <a class="anchor" id="invalid"></a></p><h5>3.2.2.7 CS_Auto</h5>
<p>The <code>CS_Auto</code> command will change the sequencing mode from manual to automatic, which means that the sequencer will automatically execute commands upon loading. This command can only be run when there are no currently executing sequences. If a sequence is executing, a <code>CS_Cancel</code> followed by a <code>CS_Auto</code> will get the sequencer back to executing sequences automatically.</p>
<h4><a class="anchor" id="autotoc_md1637"></a>
3.2.3 Port Handlers</h4>
<p><a class="anchor" id="invalid"></a></p><h5>3.2.3.1 schedIn</h5>
<p>The <code>schedIn</code> port checks to see if there is a timed command pending. If the timer for a pending command has expired, the command is dispatched. If there is a command being executed, the command timeout timer is also checked. If it has expired, a warning event is emitted and the sequence is aborted.</p>
<p><a class="anchor" id="invalid"></a></p><h5>3.2.3.2 cmdResponseIn</h5>
<p>The <code>cmdResponseIn</code> port is called when a command in a sequence is completed. If the command status is successful, the next command in the sequence is executed.</p>
<p><a class="anchor" id="seqRunIn"></a> <a class="anchor" id="invalid"></a></p><h5>3.2.3.3 seqRunIn</h5>
<p>This port takes a single argument <code>filename</code> of type <code><a class="el" href="class_fw_1_1_eighty_char_string.html">Fw::EightyCharString</a></code>. In general, sending <code>filename</code> on this port has the same effect as issuing a <code>CS_Run</code> command with <code>filename</code> as the file name argument.</p>
<p>If <code>filename</code> is empty, then <code>CmdSequencer</code> runs the sequence stored in the sequence buffer, without loading a sequence first. In order for this to work:</p>
<ul>
<li>You must already have called <a href="#loadSequence"><code>loadSequence</code></a>.</li>
<li>There must be a valid sequence in the buffer, i.e., <code>loadSequence</code> must have succeeded.</li>
<li>You must not have validated or run any sequences since calling <code>loadSequence</code>, since these operations clear the buffer.</li>
</ul>
<p><a class="anchor" id="invalid"></a></p><h5>3.2.3.4 pingIn</h5>
<p>The <code>pingIn</code> port is called by the <code>Svc::Health</code> component to verify that the <code>CmdSequencer</code> thread is still functional. The handler simply takes the provided code and calls the <code>pingOut</code> port.</p>
<h3><a class="anchor" id="autotoc_md1642"></a>
3.3 Component Structure</h3>
<h4><a class="anchor" id="autotoc_md1643"></a>
3.3.1 Types</h4>
<p>The <code>CmdSequencer</code> class defines the following types:</p>
<ul>
<li><a class="anchor" id="Sequence"></a><code>Sequence</code>: An abstract class representing a command sequence. It provides the following pure virtual functions, which its concrete subclasses must implement: <pre class="fragment">* `loadFile`: Open a named sequence file from the disk and
</pre> validate the file. Fill in the member variable <code>m_header</code> of type <a href="#Sequence_Header"><code>Sequence::Header</code></a> with the header information for the current sequence. <pre class="fragment">* `hasMoreRecords:` Return true if and only if there are more records
</pre> available in the current sequence. <pre class="fragment">* `nextRecord`: Return a [`Sequence::Record`](#Sequence_Record)
</pre> object corresponding to the next record of the current sequence. This function should succeed if <code>hasMoreRecords</code> returns <code>true</code>; otherwise it should assert. <pre class="fragment">* `reset`: Reset the current sequence to the beginning.
</pre> After calling this function, <code>hasMoreRecords</code> should return <code>true</code>, unless the sequence has zero records. <pre class="fragment">* `clear`: Clear the current sequence.
</pre> After calling this function, <code>hasMoreRecords</code> should return <code>false</code>.</li>
<li><a class="anchor" id="Sequence_Header"></a><code>Sequence::Header</code>: A class representing a sequence header. It contains member variables corresponding to the header fields of the <a href="#F_Prime_Sequence_Format">F Prime sequence format</a>.</li>
<li><a class="anchor" id="Sequence_Record"></a><code>Sequence::Record</code>: A class representing a sequence record. It contains member variables corresponding to the record fields of the <a href="#F_Prime_Sequence_Format">F Prime sequence format</a>.</li>
<li><a class="anchor" id="F_Prime_Sequence"></a><code>FPrimeSequence</code>: A concrete subclass of <a href="#Sequence"><code>Sequence</code></a> that implements the virtual functions as follows: <pre class="fragment">* `loadFile`: Open a named sequence file from the disk.
</pre> Read, deserialize, and store the header. Read the binary records into a serial buffer <em>B</em>. Extract the stored CRC from the file. Check that the file format is valid according to the binary format specified in <a href="#F_Prime_Sequence_Format"><b>F Prime Sequence Format</b></a>. Compute the CRC value of the binary header and records and check it against the stored CRC value. <pre class="fragment">* `hasMoreRecords`: Return `true` if and only if *B* has more data.

* `nextRecord`: Deserialize and return the next record stored
</pre> in the serial buffer. <pre class="fragment">* `reset`: Reset *B* for deserialization.

* `clear`: Reset *B* for serialization.
</pre></li>
</ul>
<h4><a class="anchor" id="autotoc_md1644"></a>
3.3.2 Configuration</h4>
<p><a class="anchor" id="invalid"></a></p><h5>3.3.2.1 setTimeout (Optional)</h5>
<p>The <code>setTimeout()</code> public method sets the command timeout value. When a command is being executed by a component, this value specifies a timeout in seconds that will abort the sequence if exceeded. The default value of zero means that there will be no timeout.</p>
<p><a class="anchor" id="invalid"></a></p><h5>3.3.2.2 setSequenceFormat (Optional)</h5>
<p>This function has a single argument of type <a href="#Sequence"><code>CmdSequencer::Sequence&amp;</code></a>. By default, <code>CmdSequencer</code> uses an instance of <a href="#F_Prime_Sequence"><code>FPrimeSequence</code></a> to load and run binary sequences conforming to the specification given in <a href="#F_Prime_Sequence_Format"><b>F Prime Sequence Format</b></a>. After you call <code>setSequenceFormat</code>, <code>CmdSequencer</code> uses the object passed in as its argument to load and run sequences. By defining a suitable subclass of <a href="#Sequence"><code>CmdSequencer::Sequence&amp;</code></a> and passing in an instance of this subclass, you can use a project-specific sequence format. You can also change the internal representation for the sequence: for example, you can have the <code>Sequence</code> subclass read the next record from the disk instead of loading the entire sequence into memory (in this case, the <code>loadFile</code> operation would load just the fixed-length header).</p>
<p><a class="anchor" id="invalid"></a></p><h5>3.3.2.3 allocateBuffer</h5>
<p>The <code>allocateBuffer()</code> public method passes a memory allocator to provide memory for the sequence buffer needed by <code>cmdSequencer</code>. The user will provide an instance of a sub-class of <code><a class="el" href="class_fw_1_1_mem_allocator.html">Fw::MemAllocator</a></code> that implements memory allocation. An example of this using the heap can be found in <code><a class="el" href="_malloc_allocator_8hpp.html" title="A MemAllocator implementation class that uses malloc. ">Fw/Types/MallocAllocator.hpp</a></code>.</p>
<p><a class="anchor" id="loadSequence"></a> <a class="anchor" id="invalid"></a></p><h5>3.3.2.4 loadSequence (Optional)</h5>
<p>This function takes a single argument <code>fileName</code> of type <code><a class="el" href="class_fw_1_1_eighty_char_string.html">Fw::EightyCharString</a></code>. When you call this function, <code>CmdSequencer</code> loads the sequence file <code>fileName</code> into its buffer so that you can execute it later by calling <a href="#seqRunIn"><code>seqRunIn</code></a>.</p>
<p>This function issues events, so you must connect the event topology before calling this function.</p>
<p><a class="anchor" id="invalid"></a></p><h5>3.3.2.5 deallocateBuffer</h5>
<p>The <code>deallocateBuffer()</code> method is used to deallocate the buffer supplied in <code>allocateBuffer()</code> method. It should be called before the destructor.</p>
<h4><a class="anchor" id="autotoc_md1650"></a>
3.3.3 Data formats</h4>
<p><a class="anchor" id="F_Prime_Sequence_Format"></a> <a class="anchor" id="invalid"></a></p><h5>3.3.3.1 F Prime Sequence Format</h5>
<p>An F Prime sequence file consists of a header followed by a list of records and a CRC value.</p>
<p><b>Header:</b> The format for the header is as follows. All numbers must be stored in big-endian format.</p>
<table class="doxtable">
<tr>
<th>Header Field </th><th>Size (bytes) </th><th>Description  </th></tr>
<tr>
<td>File Size </td><td>4 </td><td>Size of command record buffer following header </td></tr>
<tr>
<td>Number of records </td><td>4 </td><td>Number of records in the file </td></tr>
<tr>
<td>Time Base </td><td>2 </td><td>Time Base for sequence (0xFFFF = don't care) </td></tr>
<tr>
<td>Context </td><td>1 </td><td>Context for sequence (project specific) 0xFF = don't care </td></tr>
</table>
<p><b>Records:</b> The format for each record is as follows:</p>
<table class="doxtable">
<tr>
<th>Record Field </th><th>Size (bytes) </th><th>Description  </th></tr>
<tr>
<td>Descriptor </td><td>1 </td><td>What kind of record it is. 0 = absolute time command, 1 = relative time command, 2 = end of sequence </td></tr>
<tr>
<td>Command Time </td><td>8 </td><td>Start time of command. Depending on descriptor, will be relative or absolute. First four bytes are seconds of command, second four bytes are microseconds of command. </td></tr>
<tr>
<td>Record Size </td><td>4 </td><td>Size of command buffer </td></tr>
<tr>
<td>Command Buffer </td><td>&gt;= 4 </td><td>Buffer containing command packet descriptor, command opcode, and zero or more serialized arguments. </td></tr>
</table>
<p><b>CRC value:</b> The last 4 bytes of the file is a CRC of the entire file as computed by Utils/Hash.hpp</p>
<p><a class="anchor" id="invalid"></a></p><h5>3.3.3.2 Sequence File Generator</h5>
<p>A utility is provided that will convert a text file listing of commands and their argument to a binary sequence file.</p>
<p>It can be run by invoking:</p>
<p><code>Gse/bin/run_tinyseqgen.sh &lt;input text file&gt;</code></p>
<p>The syntax of the file is as follows:</p>
<p><code>;</code> - Comment Character. Any text after this will be ignored. Can be anywhere on a line.</p>
<p><b>Relative Time Command:</b></p>
<p><code>RHH:MM::SS.FFFF MNEMONIC A1,A2...AN</code></p>
<p>where:</p>
<p><code>R</code> - Relative time descriptor</p>
<p><code>HH</code> - delay in hours</p>
<p><code>MM</code> - delay in minutes</p>
<p><code>SS</code> - delay in seconds</p>
<p><code>.FFFF</code> - delay in fractions of a second (optional)</p>
<p><code>MNEMONIC</code> - Command mnemonic in dictionary</p>
<p><code>A1,A2...AN</code> - any arguments for the command</p>
<p><b>Immediate Command:</b></p>
<p>A no delay command is a special case of a relative delay with zero delay specified:</p>
<p><code>R00:00:00 MNEMONIC A1,A2...AN</code></p>
<p><b>Absolute Command:</b></p>
<p><code>AYYYY-DOYTHH:MM:SS.FFFF MNEMONIC A1,A2...AN</code></p>
<p>where:</p>
<p><code>R</code> - Relative time descriptor</p>
<p><code>YYYY</code> - Year</p>
<p><code>DOY</code> - Day of Year</p>
<p><code>HH</code> - delay in hours</p>
<p><code>MM</code> - delay in minutes</p>
<p><code>SS</code> - delay in seconds</p>
<p><code>.FFFF</code> - delay in fractions of a second (optional)</p>
<p><code>MNEMONIC</code> - Command mnemonic in dictionary</p>
<p><code>A1,A2...AN</code> - any arguments for the command</p>
<p>Note that the time is encoded in UTC with an epoch of 1/1/1970.</p>
<p>An example can be seen in <a href="../../../Gse/bin/simple_sequence.seq">Gse/bin/simple_sequence.seq</a></p>
<h3><a class="anchor" id="autotoc_md1653"></a>
3.4 Component State</h3>
<p>The <code>CmdSequencer</code> does not have any significant state machines.</p>
<h3><a class="anchor" id="autotoc_md1654"></a>
3.5 Component Dictionary</h3>
<p>TBD</p>
<h3><a class="anchor" id="autotoc_md1655"></a>
3.6 Component Sequences</h3>
<div class="image">
<img src="img/SequenceExecution.jpg" alt="Execute Sequence"/>
</div>
<h2><a class="anchor" id="autotoc_md1656"></a>
4 Module Checklists</h2>
<p><a href="Checklist_Design.xlsx">Design Checklist</a></p>
<p><a href="Checklist_Code.xlsx">Code Checklist</a></p>
<p><a href="Checklist_Unit_Test.xls">Unit Test Checklist</a></p>
<h2><a class="anchor" id="autotoc_md1657"></a>
5 Unit Testing</h2>
<p><a href="../test/ut/output/CmdSequencerImpl.cpp.gcov">CmdSequencerImpl.cpp</a></p>
<p><a href="../test/ut/output/CmdSequencerComponentAc.cpp.gcov">CmdSequencerComponentAc.cpp</a></p>
<h2><a class="anchor" id="autotoc_md1658"></a>
6 Change log</h2>
<table class="doxtable">
<tr>
<th>Date </th><th>Change Description  </th></tr>
<tr>
<td>2/26/2017</td><td>Version for Design/Code Review </td></tr>
<tr>
<td>4/6/2017</td><td>Version for Unit test </td></tr>
<tr>
<td>10/30/2017</td><td>Revise design to make sequence format configurable </td></tr>
</table>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="_svc.html">Svc Components Ports and Classes</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
