<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.19"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>F´ Flight Software - C/C++ Documentation: Os::Queue (Pthreads implemenation)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">F´ Flight Software - C/C++ Documentation
   &#160;<span id="projectnumber">NASA-v1.5.0</span>
   </div>
   <div id="projectbrief">A framework for building embedded system applications to NASA flight quality standards.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.19 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('_os_queue.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title"><a class="el" href="class_os_1_1_queue.html">Os::Queue</a> (Pthreads implemenation) </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md92"></a>
Os::Queue (Pthreads implemenation)</h1>
<h2><a class="anchor" id="autotoc_md93"></a>
1 Introduction</h2>
<p>The ISF <code><a class="el" href="class_os_1_1_queue.html">Os::Queue</a></code> provides a message queue interface for asynchronous ISF ports. Many operating systems provide their own inter-process communication (IPC) queues (ie. <a href="http://man7.org/linux/man-pages/man7/mq_overview.7.html">POSIX</a>, VxWorks, <a href="http://man7.org/linux/man-pages/man7/svipc.7.html">SysV</a>), which have traditionally been used as the underlying implementation for <code><a class="el" href="class_os_1_1_queue.html">Os::Queue</a></code>. In contrast, this Pthreads implementation is hand coded C++ code tailored to the ISF <code><a class="el" href="class_os_1_1_queue.html">Os::Queue</a></code> interface. Its only dependency on non-standard libraries is <a href="http://pubs.opengroup.org/onlinepubs/007908799/xsh/pthread.h.html"><code>&lt;pthread.h&gt;</code></a>, which is used for access and control flow of the internal queue data structure (ie. <a href="http://pubs.opengroup.org/onlinepubs/007908799/xsh/pthread_mutex_lock.html"><code>pthread_mutex_lock</code></a>, <a href="http://pubs.opengroup.org/onlinepubs/007908799/xsh/pthread_cond_wait.html"><code>pthread_cond_wait</code></a>, etc.). The Pthread implementation provides the following advantages over the operating system provided IPC queues:</p>
<ul>
<li>The Pthreads implementation is NOT an IPC queue. It is designed for message passing between threads in the same memory address space. This means that it never touches the filesystem and has no persistent state after the <code><a class="el" href="class_os_1_1_queue.html">Os::Queue</a></code> deconstructor has been called. ISF currently does not spread different threads of execution in different memory spaces on Darwin and Linux, so this is an acceptable solution.</li>
<li>Memory for Pthreads queues are allocated on the heap at initialization. After initialization, the memory usage of the queue remains static. The queue sizes are only limited by the amount of memory on your system. The queue size is NOT governed by arbitrary limits defined in kernel configurations, as is the case for POSIX and SysV queues.</li>
<li>Since the Pthreads implementation is handwritten, ISF developers can change the interface and add new features to support mission needs. In particular, queue usage statistics can be built in, such as high water marking, message counts, etc.</li>
</ul>
<p>The Pthread queues can be configured in one of two ways depending on mission needs: first-in-first-out (FIFO) or priority. The FIFO queue is implemented using a circular buffer with <em>O(log(1))</em> enqueue and dequeue time. The priority queue is implemented using a stable maximum binary heap with <em>O(log(n))</em> enqueue and dequeue time. Note: A <em>stable</em> maximum binary heap has the property that items pulled off the queue are in order of decreasing priority. Items of equal priority are pulled off in FIFO order.</p>
<p>NOTE: <a href="http://lxr.free-electrons.com/source/ipc/mqueue.c">POSIX queues</a> use a dynamically sized <a href="https://en.wikipedia.org/wiki/Red%E2%80%93black_tree">red-black tree</a> for the message queue data structure. This data structure also has an <em>O(log(n))</em> enqueue and dequeue time.</p>
<h2><a class="anchor" id="autotoc_md94"></a>
2 Requirements</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Requirement  </th><th class="markdownTableHeadNone">Description  </th><th class="markdownTableHeadNone">Rationale  </th><th class="markdownTableHeadNone">Verification Method   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">ISF-Q-001  </td><td class="markdownTableBodyNone">The Pthreads queue shall conform to the ISF <code><a class="el" href="class_os_1_1_queue.html">Os::Queue</a></code> interface.  </td><td class="markdownTableBodyNone">Ensures the queue can be used for ISF components  </td><td class="markdownTableBodyNone">Inspection   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">ISF-Q-002  </td><td class="markdownTableBodyNone">The Pthreads queue shall not use dynamic memory, except at initialization.  </td><td class="markdownTableBodyNone">Conform to flight software guidelines.  </td><td class="markdownTableBodyNone">Inspection   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">ISF-Q-003  </td><td class="markdownTableBodyNone">The Pthreads queue shall not use operating system parameters for size limits.  </td><td class="markdownTableBodyNone">Ensure that the queue sizes can be changed by the user without changing kernel parameters.  </td><td class="markdownTableBodyNone">Inspection   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md95"></a>
3 Design</h2>
<h3><a class="anchor" id="autotoc_md96"></a>
3.1 Constants</h3>
<p>The Pthreads queue uses the following constants, specified at instantiation:</p>
<ol type="1">
<li><a class="anchor" id="msgSize"></a><em>Message Size</em>: The maximum size of a message that can be stored in the queue.</li>
<li><a class="anchor" id="depth"></a><em>Depth</em>: The maximum number of messages that can stored in the queue.</li>
<li><a class="anchor" id="block"></a><em>Block</em>: Flag which specifies whether the queue should block when reading from an empty queue.</li>
</ol>
<h3><a class="anchor" id="autotoc_md97"></a>
3.2 State</h3>
<p>The queue maintains the following state:</p>
<ol type="1">
<li><a class="anchor" id="num_queue"></a><em>Number of Queues</em>: The current number of queues allocated in the system (static variable which starts at 0).</li>
<li><a class="anchor" id="count"></a><em>Count</em>: The current number of messages in the queue (starts at 0).</li>
<li><a class="anchor" id="maxCount"></a><em>Maximum Count</em>: The maximum number of messages ever seen in the queue since instantiation. This the a "high water mark" of the queue.</li>
<li><a class="anchor" id="queue"></a><em>Queue</em>: The queue data structure itself. The queue memory is allocated in a <code>U8*</code> buffer of size: (<a href="#msgSize">Message Size</a> + <code>sizeof(NATIVE_UINT_TYPE)</code>) * <a href="#depth">Depth</a></li>
<li><a class="anchor" id="heap"></a><em>Heap</em> (for priority queue only): The stable maximum binary heap data structure which orders stored messages with respect to priority. The size of the heap in memory is: <code>sizeof(NATIVE_UINT_TYPE)</code> * 3 * <a href="#depth">Depth</a>.</li>
</ol>
<h3><a class="anchor" id="autotoc_md98"></a>
3.3 Stable Maximum Binary Heap</h3>
<p>A maximum <a href="https://en.wikipedia.org/wiki/Binary_heap">binary heap data structure</a> is a binary tree with the following constraints:</p>
<ol type="1">
<li>It is complete, that is, all levels of the tree, except possibly the last one (deepest) are fully filled, and, if the last level of the tree is not complete, the nodes of that level are filled from left to right.</li>
<li>It satisfies the maximum heap property, that is, all nodes are either greater than or equal to each of its children.</li>
</ol>
<p>The Pthreads heap implementation is also <em>stable</em>, which means it satisfies the following additional constraint:</p>
<ol type="1">
<li>If a node has children nodes of equal value, the parent node must be "older" (inserted before) each equal-valued child node.</li>
</ol>
<p>This ensures that messages of equal priority are dequeued in FIFO order.</p>
<h2><a class="anchor" id="autotoc_md99"></a>
4 Implementation</h2>
<p>This section provides a summary of the code included in the C++ implementation files.</p>
<ul>
<li>**<code>Queue.cpp</code>:** This is the implementation of the ISF <code><a class="el" href="class_os_1_1_queue.html">Os::Queue</a></code> class. This file provides synchronization between threads reading and writing to the queue, and passes data to and from the underlying data structure.</li>
<li>**<code><a class="el" href="buffer_queue_8hpp.html">BufferQueue.hpp</a></code>:** This file outlines an interface to a generic queue data structure.</li>
<li>**<code><a class="el" href="f_i_f_o_buffer_queue_8cpp.html">FIFOBufferQueue.cpp</a></code>:** This file implements a first-in-first-out queue data structure, conforming to <code><a class="el" href="buffer_queue_8hpp.html">BufferQueue.hpp</a></code>.</li>
<li>**<code><a class="el" href="priority_buffer_queue_8cpp.html">PriorityBufferQueue.cpp</a></code>:** This file implements a priority queue data structure, conforming to <code><a class="el" href="buffer_queue_8hpp.html">BufferQueue.hpp</a></code>. It uses files in MaxHeap/ to perform priority queueing.</li>
<li>**<code><a class="el" href="buffer_queue_common_8cpp.html">BufferQueueCommon.cpp</a></code>:** This file implements various common methods for <code><a class="el" href="buffer_queue_8hpp.html">BufferQueue.hpp</a></code>.</li>
<li>**<code><a class="el" href="max_heap_8hpp.html">MaxHeap/MaxHeap.hpp</a></code>:** This file outlines an interface to a generic maximum heap data structure, where <code>NATIVE_INT_TYPE</code> is used for priority and a <code>NATIVE_UINT_TYPE</code> is stored as data.</li>
<li>**<code><a class="el" href="max_heap_8cpp.html">MaxHeap/MaxHeap.cpp</a></code>:** This file implements a stable maximum heap conforming to <code><a class="el" href="max_heap_8hpp.html">MaxHeap/MaxHeap.hpp</a></code>.</li>
</ul>
<p>Note: To use the FIFO queue implementation, a user must include <code>Queue.cpp</code>, <code><a class="el" href="f_i_f_o_buffer_queue_8cpp.html">FIFOBufferQueue.cpp</a></code>, and <code><a class="el" href="buffer_queue_common_8cpp.html">BufferQueueCommon.cpp</a></code> in the compilation. To use the priority queue implementation, the user must include <code>Queue.cpp</code>, <code><a class="el" href="priority_buffer_queue_8cpp.html">PriorityBufferQueue.cpp</a></code>, <code><a class="el" href="buffer_queue_common_8cpp.html">BufferQueueCommon.cpp</a></code>, and <code><a class="el" href="max_heap_8cpp.html">MaxHeap/MaxHeap.cpp</a></code>.</p>
<h2><a class="anchor" id="autotoc_md100"></a>
5 Unit Testing</h2>
<p>There are 3 unit tests used to validate the Pthreads queue implementation at different levels of abstraction.</p>
<h3><a class="anchor" id="autotoc_md101"></a>
5.1 Maximum Heap Unit Test</h3>
<p>The maximum heap unit tests are located in <code>Os/Pthread/MaxHeap/test/ut</code>. These tests validate the functionality of the maximum heap data structure. Test names and descriptions are listed below:</p>
<ol type="1">
<li><b>Empty Heap</b>: Make sure that removing an item from an empty heap returns an error.</li>
<li><b>Full Heap</b>: Make sure that adding an item to a full heap returns an error.</li>
<li><b>Pop</b>: Test removing an item from a filled heap.</li>
<li><b>Random Push/Pop</b>: Test adding and removing items of varied priority and ensure that they are returned off the heap in the correct order.</li>
<li><b>Equal Priority</b>: Test that items added to the queue with equal priority are popped off in FIFO order.</li>
<li><b>Mixed Priority</b>: Test that items added to the queue with both varied and equal priority are popped off in priority order and FIFO order when priorities are equal.</li>
</ol>
<h3><a class="anchor" id="autotoc_md102"></a>
5.2 Buffer Queue Unit Test</h3>
<p>The buffer queue unit tests are located in <code>Os/Pthread/test/ut</code>. These tests validate the functionality of the underlying queue data structure. Note: These tests do NOT test any blocking behavior of the queue. Test names and descriptions are listed below:</p>
<ol type="1">
<li><b>Empty Queue</b>: Make sure that removing an item from an empty queue returns an error.</li>
<li><b>Full Queue</b>: Make sure that adding an item to a full queue returns an error.</li>
<li><b>Size Mismatch</b>: Make sure that trying to receive a large message into a too-small buffer returns an error.</li>
<li><b>Pop</b>: Test removing an item from a filled queue.</li>
<li><b>Priorities</b>: Ensure that the queue returns messages in priority order, and in FIFO order for equal priorities.</li>
</ol>
<h3><a class="anchor" id="autotoc_md103"></a>
5.3 Queue Unit Test</h3>
<p>The queue unit tests are located in <code>Os/test/ut</code>. These tests validate the functionality of the queue as well as the blocking behavior at the component interface level. Test names and descriptions are listed below:</p>
<h4><a class="anchor" id="autotoc_md104"></a>
5.3.1 Blocking Queue Unit Test</h4>
<ol type="1">
<li><b>Send and Receive</b>: Test successful send and receive from a blocking queue.</li>
<li><b>Blocking Receive on Empty</b>: Test blocking behavior for receiveing on an empty queue.</li>
<li><b>Non-blocking Send on Full</b>: Test non-blocking behavior for sending to a full queue.</li>
<li><b>Send and Receive with Priorities</b>: Test that sending and receiving of messages occurs in the correct order with respect to priority.</li>
</ol>
<h4><a class="anchor" id="autotoc_md105"></a>
5.3.2 Non-blocking Queue Unit Test</h4>
<ol type="1">
<li><b>Send and Receive</b>: Test successful send and receive from a non-blocking queue.</li>
<li><b>Non-blocking Receive on Empty</b>: Test non-blocking behavior for receiving on an empty queue.</li>
<li><b>Non-blocking Send on Full</b>: Test non-blocking behavior for sending to a full queue.</li>
<li><b>Send and Receive with Priorities</b>: Test that sending and receiving of messages occurs in the correct order with respect to priority.</li>
</ol>
<h4><a class="anchor" id="autotoc_md106"></a>
5.3.3 Queue Performance Unit Test</h4>
<ol type="1">
<li><b>Shallow Queue Test</b>: 3 messages are sent on the queue, and then 3 messages are read on the queue. This test is repeated 1000000 times in a single thread and the execution time is printed.</li>
<li><b>Deep Queue Test</b>: The queue is first pre-filled to its maximum capacity (default 10). Next, test 1 is run 1000000 times and the execution time is printed.</li>
<li><b>Concurrent Queue Test</b>: Test 2 is run simultaneously using 4 threads, 50000 times for each thread, and the execution time is printed.</li>
</ol>
<h2><a class="anchor" id="autotoc_md107"></a>
6 Performance</h2>
<p>The performance results for tests 5.3.3 for the Pthreads queue and the Posix queue were run on a Virtual Box VM (hosted on a Mac) and given 4 execution cores (April 2016). The test results can be seen below:</p>
<p><b>Pthreads queue results:</b> </p><div class="fragment"><div class="line">---------------------</div>
<div class="line">- performance test --</div>
<div class="line">---------------------</div>
<div class="line">Testing shallow queue...</div>
<div class="line">Time: 1.362s (1.362us per)</div>
<div class="line">Testing deep queue...</div>
<div class="line">Time: 1.769s (1.769us per)</div>
<div class="line">Test complete.</div>
<div class="line">---------------------</div>
<div class="line">---------------------</div>
<div class="line">---------------------</div>
<div class="line">-- concurrent test --</div>
<div class="line">---------------------</div>
<div class="line">Testing deep queue...</div>
<div class="line">Time: 0.882s (17.633us per)</div>
<div class="line">Test complete.</div>
<div class="line">---------------------</div>
<div class="line">---------------------</div>
</div><!-- fragment --><p><b>Posix queue results:</b> </p><div class="fragment"><div class="line">---------------------</div>
<div class="line">- performance test --</div>
<div class="line">---------------------</div>
<div class="line">Testing shallow queue...</div>
<div class="line">Time: 3.993s (3.993us per)</div>
<div class="line">Testing deep queue...</div>
<div class="line">Time: 3.942s (3.942us per)</div>
<div class="line">Test complete.</div>
<div class="line">---------------------</div>
<div class="line">---------------------</div>
<div class="line">---------------------</div>
<div class="line">-- concurrent test --</div>
<div class="line">---------------------</div>
<div class="line">Testing deep queue...</div>
<div class="line">Time: 0.701s (14.017us per)</div>
<div class="line">Test complete.</div>
<div class="line">---------------------</div>
<div class="line">---------------------</div>
</div><!-- fragment --><p>The Pthreads queues are significantly faster than posix queues on a single core. The Pthreads queue is marginally slower in a multi-threaded environment, but its performance is still very similar to the Posix queue implementation. Based on these results the the Pthreads queue is performant enough for single core flight systems. It also looks to have reasonable performance when multi-threaded. If we wanted better multi-core performance, we could look into implementing a <a href="http://www.non-blocking.com/download/SunT03_PQueue_TR.pdf">lock-free concurrent max heap data structure</a>. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="os.html">Os Components Ports and Classes</a></li>
    <li class="footer">Generated by <a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.19 </li>
  </ul>
</div>
</body>
</html>
