<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>F´ Flight Software - C/C++ Documentation: Svc::FramingProtocol Protocol</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">F´ Flight Software - C/C++ Documentation
   &#160;<span id="projectnumber">Latest</span>
   </div>
   <div id="projectbrief">A framework for building embedded system applications to NASA flight quality standards.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('_svc_framing_protocol.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title"><a class="el" href="class_svc_1_1_framing_protocol.html" title="abstract class representing a framing protocol">Svc::FramingProtocol</a> Protocol </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md491"></a>
Svc::FramingProtocol Library</h1>
<p>The <code>FramingProtocol</code> library defines the interfaces to the framing and deframing protocols used by the <code><a class="el" href="class_svc_1_1_framer.html" title="Generic framing component using FramingProtocol implementation for actual framing.">Svc::Framer</a></code> and <code><a class="el" href="class_svc_1_1_deframer.html" title="Generic deframing component using DeframingProtocol implementation for actual deframing.">Svc::Deframer</a></code> components. <code><a class="el" href="class_svc_1_1_framer.html" title="Generic framing component using FramingProtocol implementation for actual framing.">Svc::Framer</a></code> uses a framing protocol to wrap data in frames for transmission to the ground. <code><a class="el" href="class_svc_1_1_deframer.html" title="Generic deframing component using DeframingProtocol implementation for actual deframing.">Svc::Deframer</a></code> uses a deframing protocol to extract data from frames received from the ground. The <code>FramingProtocol</code> library allows each of these components to operate with any one of several protocols. Each protocol corresponds to a different implementation of an interface provided by this library.</p>
<p>This library implements default F' protocols that work with the F' Ground Data System (GDS). The F' protocols use the following frame format: frame header, data, hash value. A frame header consists of a four-byte start word <code>0xDEADBEEF</code> and a four byte data size. The hash value is defined by the <code><a class="el" href="class_utils_1_1_hash.html" title="A generic interface for creating and comparing hash values.">Utils::Hash</a></code> library.</p>
<p>Users may provide new protocols by implementing the abstract classes defined in the <code>FramingProtocol</code> library.</p>
<h2><a class="anchor" id="autotoc_md492"></a>
1. Requirements</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Requirement   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Verification Method    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Svc-FramingProtocol-001   </td><td class="markdownTableBodyNone"><code><a class="el" href="class_svc_1_1_framing_protocol.html" title="abstract class representing a framing protocol">Svc::FramingProtocol</a></code> shall provide the interface to a protocol for wrapping data in frames for transmission to the ground   </td><td class="markdownTableBodyNone">Unit test    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Svc-FramingProtocol-002   </td><td class="markdownTableBodyNone"><code><a class="el" href="class_svc_1_1_framing_protocol.html" title="abstract class representing a framing protocol">Svc::FramingProtocol</a></code> shall provide the interface to a protocol for extracting data from frames received from the ground   </td><td class="markdownTableBodyNone">Unit test    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Svc-FramingProtocol-003   </td><td class="markdownTableBodyNone"><code><a class="el" href="class_svc_1_1_framing_protocol.html" title="abstract class representing a framing protocol">Svc::FramingProtocol</a></code> shall implement the framing and deframing protocols used by the F Prime GDS   </td><td class="markdownTableBodyNone">Unit test   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md493"></a>
2. Using the Interface</h2>
<h3><a class="anchor" id="autotoc_md494"></a>
2.1. Framing</h3>
<p>To use the F' framing protocol, do the following:</p>
<ol type="1">
<li>Instantiate the class <code>FprimeFraming</code> defined in this library.</li>
</ol>
<ol type="1">
<li>Instantiate the <code><a class="el" href="class_svc_1_1_framer.html" title="Generic framing component using FramingProtocol implementation for actual framing.">Svc::Framer</a></code> component, passing the instance created in step 1 to its <code>setup</code> method.</li>
</ol>
<p>For an example, see the definition of the instance <code>downlink</code> at <code>Ref/Top/instances.fpp</code>.</p>
<p>To implement and use a new framing protocol, do the following:</p>
<ol type="1">
<li>Implement the abstract class <code>FramingProtocolInterface</code> as discussed in Section 3.1. This class defines helper operations used when framing a packet.</li>
</ol>
<ol type="1">
<li>Implement the abstract class <code>FramingProtocol</code> as discussed in Section 3.1. This class defines the operation of framing a data packet.</li>
</ol>
<ol type="1">
<li>Instantiate the class implemented in step 1.</li>
</ol>
<ol type="1">
<li>Instantiate the class implemented in step 2, passing the instance created in step 3 to its <code>setup</code> method.</li>
</ol>
<ol type="1">
<li>Instantiate the <code><a class="el" href="class_svc_1_1_framer.html" title="Generic framing component using FramingProtocol implementation for actual framing.">Svc::Framer</a></code> component, passing the instance created in step 4 to its <code>setup</code> method.</li>
</ol>
<h3><a class="anchor" id="autotoc_md495"></a>
2.2. Deframing</h3>
<p>To use the F' deframing protocol, do the following:</p>
<ol type="1">
<li>Instantiate the class <code>FprimeDeframing</code> defined in this library.</li>
</ol>
<ol type="1">
<li>Instantiate the <code><a class="el" href="class_svc_1_1_deframer.html" title="Generic deframing component using DeframingProtocol implementation for actual deframing.">Svc::Deframer</a></code> component, passing the instance created in step 1 to its <code>setup</code> method.</li>
</ol>
<p>For an example, see the definition of the instance <code>uplink</code> at <code>Ref/Top/instances.fpp</code>.</p>
<p>To implement and use a new deframing protocol, do the following:</p>
<ol type="1">
<li>Implement the abstract class <code>DeframingProtocolInterface</code> as discussed in Section 3.2. This class defines helper operations used when deframing a framed packet.</li>
</ol>
<ol type="1">
<li>Implement the abstract class <code>DeframingProtocol</code> as discussed in Section 3.2. This class defines the operation of deframing a framed packet.</li>
</ol>
<ol type="1">
<li>Instantiate the class implemented in step 1.</li>
</ol>
<ol type="1">
<li>Instantiate the class implemented in step 2, passing the instance created in step 3 to its <code>setup</code> method.</li>
</ol>
<ol type="1">
<li>Instantiate the <code><a class="el" href="class_svc_1_1_deframer.html" title="Generic deframing component using DeframingProtocol implementation for actual deframing.">Svc::Deframer</a></code> component, passing the instance created in step 4 to its <code>setup</code> method.</li>
</ol>
<h2><a class="anchor" id="autotoc_md496"></a>
3. Implementing a Protocol</h2>
<h3><a class="anchor" id="autotoc_md497"></a>
3.1. Framing</h3>
<p>To implement a framing protocol, do the following:</p>
<ol type="1">
<li>Implement the abstract class <code>FramingProtocolInterface</code>.</li>
<li>Use the implementation in step 1 to implement the abstract class <code>FramingProtocol</code>.</li>
</ol>
<p>Implementations of the framing protocol are allowed to produce zero or one frame for each incoming packet. Producing zero packets is useful when aggregating packets into a larger frame. Producing more than one packet is not permitted.</p>
<h4><a class="anchor" id="autotoc_md498"></a>
3.1.1. Implementing &lt;tt&gt;FramingProtocolInterface&lt;/tt&gt;</h4>
<p><code>FramingProtocolInterface</code> defines helper methods for framing data. Typically these methods are implemented by an F Prime component (e.g., <code><a class="el" href="class_svc_1_1_framer.html" title="Generic framing component using FramingProtocol implementation for actual framing.">Svc::Framer</a></code>), because they require port invocations. The component <code><a class="el" href="class_svc_1_1_framer.html" title="Generic framing component using FramingProtocol implementation for actual framing.">Svc::Framer</a></code> provides an implementation of <code>FramingProtocolInterface</code> that you can use. It does this by inheriting from <code>FramingProtocolInterface</code> and implementing its abstract methods.</p>
<p>To implement <code>FramingProtocolInterface</code>, you must implement the following pure virtual methods:</p>
<div class="fragment"><div class="line">{c++}</div>
<div class="line">   virtual Fw::Buffer allocate(const U32 size) = 0;</div>
<div class="line"> </div>
<div class="line">   virtual void send(Fw::Buffer&amp; outgoing) = 0;</div>
</div><!-- fragment --><p>The method <code>allocate</code> should accept a size in bytes and return an <code><a class="el" href="class_fw_1_1_buffer.html">Fw::Buffer</a></code> that (1) points to a memory allocation of at least that size if the allocation succeeded; or (2) has size zero if the allocation failed. A typical implementation invokes a port connected to a memory allocation component.</p>
<p>The method <code>send</code> should send the data stored in the buffer. A typical implementation invokes an <code>Fw::BufferSend</code> port.</p>
<h4><a class="anchor" id="autotoc_md499"></a>
3.1.2. Implementing &lt;tt&gt;FramingProtocol&lt;/tt&gt;</h4>
<p><code>FramingProtocol</code> defines the operation of framing a packet. To implement <code>FramingProtocol</code>, you must implement the following pure virtual method:</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">virtual void frame(const U8* const data, const U32 size, Fw::ComPacket::ComPacketType packet_type) = 0;</div>
</div><!-- fragment --><p>This method is called with the following arguments:</p>
<ul>
<li><code>data</code>: A pointer to the data to frame.</li>
<li><code>size</code>: The number of bytes to frame.</li>
<li><code>packet_type</code>: The type of data to frame.</li>
</ul>
<p>The abstract class <code>FramingProtocol</code> provides a protected member <code>m_interface</code>. This member is a pointer, initially null. After the <code>setup</code> method of <code>FramingProtocol</code> is called, it points to a concrete instance of <code>FramingProtocolInterface</code>.</p>
<p>Your implementation of <code>frame</code> should do the following:</p>
<ol type="1">
<li>Use <code>m_interface-&gt;allocate</code> to allocate a buffer to hold the framed data.</li>
<li>Frame the data into the buffer allocated in step 1.</li>
<li>Use <code>m_interface-&gt;send</code> to send the buffer. <code>m_interface-&gt;send</code> should be called at most once in any single invocation of <code>frame</code>. Aggregating protocols may only call <code>m_interface-&gt;send</code> for occasional invocations of <code>frame</code>.</li>
</ol>
<h3><a class="anchor" id="autotoc_md500"></a>
3.2. Deframing</h3>
<p>To implement a deframing protocol, do the following:</p>
<ol type="1">
<li>Implement the abstract class <code>DeframingProtocolInterface</code>.</li>
</ol>
<ol type="1">
<li>Use the implementation in step 1 to implement the abstract class <code>DeframingProtocol</code>.</li>
</ol>
<h4><a class="anchor" id="autotoc_md501"></a>
3.2.1. Implementing &lt;tt&gt;DeframingProtocolInterface&lt;/tt&gt;</h4>
<p><code>DeframingProtocolInterface</code> defines helper methods for deframing data. Typically these methods are implemented by an F Prime component (e.g., <code><a class="el" href="class_svc_1_1_deframer.html" title="Generic deframing component using DeframingProtocol implementation for actual deframing.">Svc::Deframer</a></code>), because they require port invocations. The component <code><a class="el" href="class_svc_1_1_deframer.html" title="Generic deframing component using DeframingProtocol implementation for actual deframing.">Svc::Deframer</a></code> provides an implementation of <code>DeframingProtocolInterface</code> that you can use. It does this by inheriting from <code>DeframingProtocolInterface</code> and implementing its abstract methods.</p>
<p>To implement <code>DeframingProtocolInterface</code>, you must implement the following pure virtual methods:</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">virtual Fw::Buffer allocate(const U32 size) = 0;</div>
<div class="line"> </div>
<div class="line">virtual void route(Fw::Buffer&amp; data) = 0;</div>
</div><!-- fragment --><p>The method <code>allocate</code> should allocate memory, as described in Section 3.1.1.</p>
<p>The method <code>route</code> should send (route) the data stored in the buffer. A typical implementation invokes either an <code>Fw::Com</code> port (e.g., for sending commands) or a <code>Fw::BufferSend</code> port (e.g., for sending file packets).</p>
<h4><a class="anchor" id="autotoc_md502"></a>
3.2.2. Implementing &lt;tt&gt;DeframingProtocol&lt;/tt&gt;</h4>
<p><code>DeframingProtocol</code> defines the operation of deframing a packet. To implement <code>DeframingProtocol</code>, you must implement the following pure virtual method:</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">virtual DeframingStatus deframe(Types::CircularBuffer&amp; buffer, U32&amp; needed) = 0;</div>
</div><!-- fragment --><p>This method is called with the following arguments:</p>
<ul>
<li><code>buffer</code>: A circular buffer holding the data to deframe.</li>
<li><code>needed</code>: A reference for returning the number of bytes needed for deframing.</li>
</ul>
<p><code>deframe</code> returns a value of type <code>DeframingStatus</code> indicating what happened.</p>
<p>The abstract class <code>DeframingProtocol</code> provides a protected member <code>m_interface</code>. It operates as described in Section 3.1.2.</p>
<p>Your implementation of <code>deframe</code> should do the following:</p>
<ol type="1">
<li>Determine how many bytes are needed for deframing, peeking into the circular buffer if necessary (e.g., to read a length).</li>
</ol>
<ol type="1">
<li>If that many bytes are available in the circular buffer:<ol type="a">
<li>Use <code>m_interface-&gt;allocate</code> to allocate an <code><a class="el" href="class_fw_1_1_buffer.html">Fw::Buffer</a></code> to hold the deframed data.</li>
</ol>
<ol type="a">
<li>Deframe the data into the allocated buffer. The deframing operation should read, but not delete bytes from, the buffer.</li>
</ol>
<ol type="a">
<li>Use <code>m_interface-&gt;route</code> to send the buffer.</li>
</ol>
</li>
</ol>
<ol type="1">
<li>Set <code>needed</code> to record the number of bytes needed.</li>
</ol>
<ol type="1">
<li>Return status.</li>
</ol>
<h2><a class="anchor" id="autotoc_md503"></a>
4. Default F' Implementation</h2>
<h3><a class="anchor" id="autotoc_md504"></a>
4.1. Framing</h3>
<p>The F Prime framing protocol operates as follows:</p>
<ol type="1">
<li>Compute the size of the data stored in the frame (the "frame data size")<ol type="a">
<li>If <code>packet_type</code> is <code><a class="el" href="class_fw_1_1_com_packet.html#a715f7261d313574f50a43b12914db425a89bc97f02f96b31614df715ff6e36eb0">Fw::ComPacket::FW_PACKET_UNKNOWN</a></code>, then the frame data size is the size of the provided data.</li>
</ol>
<ol type="a">
<li>Otherwise the frame data size is the size of the provided data plus four bytes for the serialized packet type.</li>
</ol>
</li>
</ol>
<ol type="1">
<li>Compute the frame size: frame data size plus frame header size plus hash value size.</li>
</ol>
<ol type="1">
<li>Allocate a buffer large enough to hold the frame.</li>
</ol>
<ol type="1">
<li>Serialize the start word and frame data size into the buffer. This operation forms the frame header.</li>
</ol>
<ol type="1">
<li>Serialize the frame data:<ol type="a">
<li>Serialize the packet type if known.</li>
</ol>
<ol type="a">
<li>Serialize the provided data. <b>Note: The F Prime GDS assumes that the first four bytes of data are the serialized packet type. Therefore, if the packet type is unknown (no serialization in the previous step), then the first four bytes of the incoming data must contain the serialized packet type.</b></li>
</ol>
</li>
</ol>
<ol type="1">
<li>Calculate and serialize the hash value.</li>
</ol>
<ol type="1">
<li>Set the buffer size to the frame size, in case the allocator returned a larger buffer.</li>
</ol>
<ol type="1">
<li>Send the buffer.</li>
</ol>
<h3><a class="anchor" id="autotoc_md505"></a>
4.2. Deframing</h3>
<p>The F Prime deframing protocol operates as follows:</p>
<ol type="1">
<li>Check whether at least 8 bytes (the frame header size) are available in the circular buffer. If not, report that many bytes needed and return status.</li>
</ol>
<ol type="1">
<li>Read the start word and data size out of the circular buffer.</li>
</ol>
<ol type="1">
<li>Compute the frame size: frame header size plus data size plus hash value size.</li>
</ol>
<ol type="1">
<li>Check that the frame size is valid. If not, return with error.</li>
</ol>
<ol type="1">
<li>Check that the circular buffer has enough bytes for the rest of the frame. If not, report the number of bytes needed and return status.</li>
</ol>
<ol type="1">
<li>Validate the hash value. If it is not valid, return status.</li>
</ol>
<ol type="1">
<li>Allocate a buffer large enough to hold the frame data. Set its size to be exactly the frame data size.</li>
</ol>
<ol type="1">
<li>Serialize the frame data into the buffer.</li>
</ol>
<ol type="1">
<li>Send the buffer.</li>
</ol>
<ol type="1">
<li>Return success status.</li>
</ol>
<h2><a class="anchor" id="autotoc_md506"></a>
5. Class Diagrams</h2>
<p><img src="./img/framingProtocol_impl_diagram.png" alt="FramingProtocol Impl Diagram" class="inline"/></p>
<p>Diagram view of DeframingProtocol:</p>
<p><img src="./img/deframingProtocol_impl_diagram.png" alt="DeframingProtocol Impl Diagram" class="inline"/></p>
<p><em>Diagrams generated with <a href="https://github.com/CoatiSoftware/Sourcetrail">SourceTrail</a></em></p>
<h2><a class="anchor" id="autotoc_md507"></a>
6. Change Log</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Date   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">2021-01-30   </td><td class="markdownTableBodyNone">Initial Draft    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">2021-02-15   </td><td class="markdownTableBodyNone">Revised   </td></tr>
</table>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="svc.html">Svc Components, Ports, and Classes</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
